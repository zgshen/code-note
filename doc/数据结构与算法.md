
## 1. 数据结构

在计算机科学中，数据结构是计算机存储、组织数据的方式。

常见的数据结构有数组、链表、堆、栈、队列、散列表、树和图。

### 1.1. 数组

数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序存储，访问方式是随机访问。利用下标查找数组元素的时间复杂度是 O（1），中间插入、删除数组元素的时间复杂度是 O（n）。

数组随机读取和更新元素方便，插入和删除操作要移动元素或扩容，若是移动大量元素会影响效率。数组适合读操作多，写操作少的场景。

### 1.2. 链表

链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查找链表节点的时间复杂度是 O（n），中间插入、删除节点的时间复杂度是 O（1）。

链表插入和删除操作灵活，读取只能顺序遍历无法快速定位元素。

### 1.3. 队列

队列是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。

### 1.4. 堆

堆（英语：Heap）是计算机科学中的一种特别的完全二叉树。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于）C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。

### 1.5. 栈

栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和出栈操作，遵循先入后出的原则（FILO）。

### 1.6. 树

树是 n 个节点的有限集，有且仅有一个特定的称为根的节点。当 n>1 时，其余节点可分为 m 个互不相交的有限集，每一个集合本身又是一个树，称为根的子树。

#### 1.6.1. 二叉树

二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点。二叉树包含完全二叉树和满二叉树两种特殊形式。

根据节点之间的位置关系遍历二叉树，可以分为前序遍历、中序遍历、后序遍历、层序遍历这4种方式；从更宏观的角度划分，可以划分为深度优先遍历和广度优先遍历两大类。

结构
```java
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode() {
    }

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

前序遍历，根节点->左节点->右节点
```java
private static void preOrderTraverse(TreeNode node) {
    if (node == null) {
        return;
    }
    System.out.println(node.val);
    preOrderTraverse(node.left);
    preOrderTraverse(node.right);
}
```

中序遍历，左节点->根节点->右节点
```java
private static void middleOrderTraverse(TreeNode node) {
    if (node == null) {
        return;
    }
    middleOrderTraverse(node.left);
    System.out.println(node.val);
    middleOrderTraverse(node.right);
}
```

前序遍历，左节点->右节点->根节点
```java
private static void afterOrderTraverse(TreeNode node) {
    if (node == null) {
        return;
    }
    afterOrderTraverse(node.left);
    afterOrderTraverse(node.right);
    System.out.println(node.val);
}
```

广度优先遍历，利用队列辅助实现
```java
public static void levelOrderTraverse(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        System.out.println(node.val);
        if (node.left != null) {
            queue.offer(node.left);
        }
        if (node.right != null) {
            queue.offer(node.right);
        }
    }
}
```

深度优先遍历，可利用栈的回溯特性实现。
```java
private static void preOderTraverseByStack(TreeNode node) {
    Stack<TreeNode> stack = new Stack<>();
    while (node != null || !stack.isEmpty()) {
        while (node != null) {
            System.out.println(node.val);
            stack.push(node);
            node = node.left;
        }
        if (!stack.isEmpty()) {
            node = stack.pop();
            node = node.right;
        }
    }
}
```

#### 1.6.2. 二叉堆

二叉堆本质上是一种完全二叉树，它分为最小堆和最大堆两种类型，见以上堆介绍。

堆的插入操作是单一节点的“上浮”，堆的删除操作是单一节点的“下沉”，这两个操作的平均交换次数都是堆高度的一半，所以时间复杂度是 O（logn）。堆的构建是吧一个完全无序的二叉树调整为二叉堆，本质是让所有非叶子节点依次“下沉”，时间复杂度是 O（n）。

插入上浮
```java
/**
  * 插入操作，上浮调整
  */
public static void upAdjust(int[] array) {
    int childIndex = array.length - 1;//插入节点下标，数组最后一个元素
    /**
      * 计算父节点下标
      * 若当前是左节点，父节点下标为（节点下标-1）/2
      * 若当前是右节点，减1为奇数，（节点下标-1）/2 向下取整结果也等于左节点的情况
      */
    int parentIndex = (childIndex - 1)/2;

    int temp = array[childIndex];//调整的数
    while (childIndex>0 && temp < array[parentIndex]) {
        array[childIndex] = array[parentIndex];
        childIndex = parentIndex;
        parentIndex = (parentIndex - 1)/2;
    }
    array[childIndex] = temp;
}
```

删除或构建下沉
```java
/**
  * 下沉调整
  * 删除操作，最后一个元素替换一个元素再做下沉操作
  * @param array 源数组
  * @param parentIndex 要调整节点的父节点下标
  * @param length 数组长度
  */
public static void downAdjust(int[] array, int parentIndex, int length) {
    int temp = array[parentIndex];
    int childIndex = 2 * parentIndex + 1;//左节点
    //判断是否属于数组
    while (childIndex < length) {
        //判断右节点是否小于左节点，成立定位到右节点
        if (childIndex + 1 < length && array[childIndex + 1] < array[childIndex]) {
            childIndex ++;
        }
        //父节点小于任意子节点，不必操作
        if (temp <= array[childIndex]) {
            break;
        }
        //父大于子，下沉
        array[parentIndex] = array[childIndex];
        //继续下一层遍历判断
        parentIndex = childIndex;
        childIndex = 2 * parentIndex + 1;
    }
    array[parentIndex] = temp;
}

/**
  * 构建堆，所有非叶子节点依次做下沉操作
  * @param array
  */
public static void buildHeap(int[] array) {
    for (int i = (array.length-2)/2; i >= 0; i--) {
        downAdjust(array, i, array.length);
    }
}
```

### 1.7. 散列表

哈希表也叫散列表，是存储 Key-Value 映射的集合。对于某一个 Key，哈希表可以在接近 O（1）的时间内进行读写操作。哈希表通过哈希函数实现 Key 和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突。

散列表本身是一个数组，需要通过哈希函数把Key进行处理以确定元素存放位置的数组下标。在 Java 中，每个对象都有自己的 hashcode，所以简单的计算方式可以按数组长度进行取模运算
```java
index = HashCode (Key) % Array.length
```

JDK 哈希函数不是直接使用取模运算，而是利用了位运算的方式来优化性能
```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```


### 1.8. 图

## 2. 算法

计算机中一系列程序指令，用于处理特定的运算和逻辑问题。

### 2.1. 算法复杂度
#### 2.1.1. 时间复杂度
**常数时间操作：**  
- 算数运算：+ - * /  

- 位运算：>>（带符号右移动）、 >>>（不带符号右移动） 、 <<、 | 、& 、^  
  带符号就是最高位补符号位，不带符号就是最高位补0

- 赋值操作：比较，自增，自减操作  

- 数组寻址等

>> 总之，执行时间固定的操作都是常数时间的操作。反之执行时间不固定的操作，都不是常数时间的操作  

**通过基本动作的常数时间，推导时间复杂度**  
对于双层循环来说，n*（常数）+ (n-1)(常数)+ ... + 2(常数) + 1*（常数） => 推导出  
`y = an^2 + bn + c`  
忽略掉低阶项，忽略掉常数项，忽略掉高阶项的系数，得到时间复杂度为 n^2。

#### 2.1.2. 空间复杂度
申请有限几个变量，和样本量n没关系，就是空间复杂度 O(1)，如果要开辟一个空间数组和样本量 n 是一样大，用来支持我们的算法流程那么 O(N)。反之用户就是要实现数组拷贝，我们开辟一个新的 n 大小数组用来支撑用户的需求，那么仍然是 O(1)。

### 2.2. 排序算法
#### 2.2.1. 冒泡排序

#### 2.2.2. 选择排序

#### 2.2.3. 插入排序

#### 2.2.4. 快速排序

#### 2.2.5. 归并排序

#### 2.2.6. 堆排序

#### 2.2.7. 桶排序

### 2.3. 贪心算法

### 2.4. 递归算法

### 2.5. 跳表

### 2.6. 动态规划



**参考**
- [1] [堆 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D)
- [2] [漫画算法：小灰的算法之旅](https://book.douban.com/subject/33420587/)