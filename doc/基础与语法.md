
#### JDK和JRE有什么区别？

- JRE：Java Runtime Environment（ java 运行时环境）。即java程序的运行时环境，包含了 java 虚拟机，java基础类库。

- JDK：Java Development Kit（ java 开发工具包）。即java语言编写的程序所需的开发工具包。JDK 包含了 JRE，同时还包括 java 源码的编译器 javac、监控工具 jconsole、分析工具 jvisualvm等。


#### ==和equals的区别是什么?

- == 是关系运算符，equals() 是方法，结果都返回布尔值
- Object 的 == 和 equals() 比较的都是地址，作用相同


#### hashCode()相同，equals()也一定为true吗？
不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。
- 类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。
- hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。

关于 hashCode() 和 equals() 是方法是有一些 常规协定：  
1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。  
2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。  
3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。

#### Math.round(-1.5) 等于多少？
运行结果： -1  
JDK 中的 java.lang.Math 类  
- ceil() ：向上取整，返回小数所在两整数间的较大值，返回类型是 double，如 -1.5 返回 -1.0
- floor() ：向下取整，返回小数所在两整数间的较小值，返回类型是 double，如 -1.5 返回 -2.0
- round() ：朝正无穷大方向返回参数最接近的整数，可以换算为 参数 + 0.5 向下取整，返回值是 int 或 long，如 -1.5 返回 -1


#### String属于基础类型么？java八种基本类型？
不属于。  
Java 中 8 种基础的数据类型：byte、short、char、int、long、float、double、boolean  
但是 String 类型却是最常用到的引用类型。

#### 普通类和抽象类有哪些区别
- 抽象类不能被实例化
- 抽象类可以有抽象方法，抽象方法只需申明，无需实现
- 含有抽象方法的类必须申明为抽象类
- 抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类
- 抽象方法不能被声明为静态
- 抽象方法不能用 private 修饰
- 抽象方法不能用 final 修饰

#### 抽象类必须要有抽象方法吗
不一定。如
```java
public abstract class TestAbstractClass {
 
	public static void notAbstractMethod() {
		System.out.println("I am not a abstract method.");
	}
	
}
```

#### throw和throws的区别
throw：
- 表示方法内抛出某种异常对象(只能是一个)
- 用于程序员自行产生并抛出异常
- 位于方法体内部，可以作为单独语句使用
- 如果异常对象是非 RuntimeException 则需要在方法申明时加上该异常的抛出，即需要加上 throws 语句 或者 在方法体内 try catch 处理该异常，否则编译报错
- 执行到 throw 语句则后面的语句块不再执行

throws：
- 方法的定义上使用 throws 表示这个方法可能抛出某些异常(可以有多个)
- 用于声明在该方法内抛出了异常
- 必须跟在方法参数列表的后面，不能单独使用
- 需要由方法的调用者进行异常处理


#### return与finally的执行顺序对返回值的影响
对于 try 和 finally 至少一个语句块包含 return 语句的情况：
- finally 语句块会执行
- finally 没有 return，finally 对 return 变量的重新赋值修改无效
- try 和 finally 都包含return，return 值会以 finally 语句块 return 值为准

#### 动态代理是什么？应用场景？如何实现
动态代理：在运行时，创建目标类，可以调用和扩展目标类的方法。  

Java 中实现动态的方式：
- JDK 中的动态代理 
- Java类库 CGLib

应用场景：
- 统计每个 api 的请求耗时
- 统一的日志输出
- 校验被调用的 api 是否已经登录和权限鉴定
- Spring的 AOP 功能模块就是采用动态代理的机制来实现切面编程

实现：
- JDK 动态代理
- CGLib 动态代理
- 使用 Spring aop 模块完成动态代理功能

#### 深拷贝和浅拷贝区别是什么
复制一个 Java 对象
- 浅拷贝：复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针，不复制堆内存中的对象。（复制的是全新的对象，属性都复制了，除了子类对象还是跟被复制的子类对象是同一个）
- 深拷贝：复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针和堆内存中的对象。

浅拷贝实现：
- 实现 Cloneable 接口，重写 clone() 方法
- 不实现 Cloneable 接口，会报 CloneNotSupportedException 异常
- Object 的 clone() 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。

#### 对面向对象的理解
对 Java 语言来说，一切皆是对象。

对象有以下特点：
- 对象具有属性和行为
- 对象具有变化的状态
- 对象具有唯一性
- 对象都是某个类别的实例
- 一切皆为对象，真实世界中的所有事物都可以视为对象

面向对象的特性：
- 抽象性：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。
- 继承性：指子类拥有父类的全部特征和行为，这是类之间的一种关系。Java 只支持单继承。
- 封装性：封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息。
- 多态性：多态性体现在父类的属性和方法被子类继承后或接口被实现类实现后，可以具有不同的属性或表现方式。

#### 内存泄漏和内存溢出的区别
- 内存溢出(out of memory)：指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory。
- 内存泄露(memory leak)：指程序在申请内存后，无法释放已申请的内存空间，内存泄露堆积会导致内存被占光。(静态集合类、各类数据库和网络连接用完不关闭、内部类持有外部类、改变哈希值)
- memory leak 最终会导致 out of memory。

#### String s="a"+"b"+"c"+"d";创建了几个对象？
1个  
编译器会优化，相当于直接定义一个 "abcd" 的字符串。


#### Lambda
单抽象方法接口

#### JDK8中Stream接口的常用方法
中间操作：
- filter：过滤元素
- map：映射，将元素转换成其他形式或提取信息
- flatMap：扁平化流映射
- limit：截断流，使其元素不超过给定数量
- skip：跳过指定数量的元素
- sorted：排序
- distinct：去重

终端操作：
- anyMatch：检查流中是否有一个元素能匹配给定的谓词
- allMatch：检查谓词是否匹配所有元素
- noneMatch：检查是否没有任何元素与给定的谓词匹配
- findAny：返回当前流中的任意元素（用于并行的场景）
- findFirst：查找第一个元素
- collect：把流转换成其他形式，如集合 List、Map、Integer
- forEach：消费流中的每个元素并对其应用 Lambda，返回 void
- reduce：归约，如：求和、最大值、最小值
- count：返回流中元素的个数







