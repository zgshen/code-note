#### 1、支持五种数据类型  
- string 字符串  （value最大存储512M）
- hash 哈希（元素最多2^32-1）
- list 列表（元素最多2^32-1）
- set 集合（元素最多2^32-1）
- sorted set 有序集合（同set）

#### 2、单线程但性能依然好原因
- 单线程避免线程切换的消耗（redis6已支持多线程）
- 基于内存，内存读写都很快的 
- 使用高性能数据结构，比如hash和跳表
- 使用非阻塞的IO多路复用机制

#### 3、持久化
- RDB：单文件灾难恢复操作简单，性能较高；每隔一段时间持久化，故障可能导致数据丢失
- AOF：日志追加，记录每个命令操作到 aof 文件中一次，宕机保证数据不会丢失，redis-check-aof 工具解决数据一致性问题；持久化文件较大，恢复速度慢
	
#### 4、过期键删除策略：定时删除（创建定时器达到过期时间删除）、惰性删除（当获取键时才检查是否删除）、定期删除（定期统一检查删除）
redis采用惰性删除和定期删除结合的策略
	
#### 5、常用客户端：Redisson、Jedis、Lettuce

#### 6、处理过大量的key同一时间过期吗？需要注意什么？
可能导致Redis短时间卡顿现象，量大时还可能出现缓存雪崩。过期时间不要求很精确的话，在时间上加一个随机值，使过期时间分散一些

#### 7、适用场景
- 数据缓存
- 计数器、排行榜
- 集合队列，发布和订阅

#### 8、key搜索禁止使用keys命令（key很多时搜索会导致线程堵塞），应该使用scan命令

#### 9、分布式锁：定义一个key，value为请求唯一id，设置超时时间，setnx成功即获得锁，删除key要校验value（可用lua脚本把读和删除原子化）

#### 10、pipeline
建立管道长链路，一次性处理多个命令，提高吞吐量，但不能保证原子操作

#### 11、缓存穿透、击穿和雪崩
- 缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
    - 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力；或者查询返回的数据为空仍然进行缓存，过期时间设置较短。
- 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
    - 使用互斥锁(mutex key)SETNX。缓存失效的时候，不立即去load db，而是去set一个mutex key，成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。
- 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
    - 在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件

#### 12、Redis集群不可用（集群三主三从，至少需要三台机器，互为主从，一台服务器宕机还能用）
- 半数宕机（fail一个主节点需要一半主以上投票通过）
- 某一结点主从全都宕机

#### 18、使用场景
- 会话缓存(Session Cache)，是 Redis 最常使用的一种情景
- 全页缓存(FPC)
- 用作网络版集合和队
- 排行榜和计数器，Redis 在内存中对数字递增、递减的操作实现的非常好。Set 和 Sorted Set 使得我们在执行这些操作的时候非常简单
- 发布和订阅