### 一、计算机基础
#### 1、HTTP状态码
- 200 ok
- 204 No Content 请求成功，不包含实体
- 301 永久重定向
- 302 临时重定向
- 400 Bad Request 请求有语法错误
- 401 认证失败
- 403 请求拒绝
- 404 Not Found
- 500 服务器内部错误（程序异常抛出之类错误）
- 503 Service Unavailable 服务不可达（oom，栈溢出宕机等情况，无法处理请求）

#### 2、TCP三次握手和四次挥手（连接三次，断开四次）
##### 连接握手
- 第一步：客户端发送syn（同步应答编号）包到服务器，等确认
- 第二步：服务的收到syn包，确认syn并向客户端发送syn和ack（确认应答）包
- 第三步：客户端收到syn和ack包之后向服务端发送确认包ack，完毕双发进入ESTABLISHED（TCP连接成功）状态，完成三次握手
##### 关闭挥手
- 第一步：客户端发送FIN报文到服务端
- 第二步：服务端收到连接释放报文后发出确认ack
- 第三步：服务端若数据发送完毕了，发送FIN=1连接释放报文到客户端
- 第四步：

为什么：关闭连接时，服务端收到FIN报文后，不会立即关闭连接，只回复ACK报文，要等服务端全部报文发送完了知乎才发送FIN报文，所以多了一步

#### 3、进程、线程和协程区别
- 程序执行时的一个实例，进程至少包含一个线程，同进程里多个线程可容易共享数据，不同进程切换代价大
- 线程是cpu调度的最小单位，开销较小，是进程的一个实体
	
### 二、Java内存模型
#### 1、主内存和工作内存
规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成

#### 2、volatile禁止指令重排序，保证变量对所有线程的可见性
单例模式用到，new对象不是原子操作，分三步
- 分配内存空间
- 初始化对象
- 对象引用指向分配的地址  

由于cpu可能的优化排序，第三步可能会先与第二步执行，这时其他线程读到就会由问题，可用volatile禁止指令重排序避免此问题

#### 3、三个特性
- 原子性：一个操作中cpu不能中断，要么不执行，要么执行完成
- 可见性：多线程访问变量，一个线程修改了变量，其他线程能够立即看到修改值
- 有序性：按照代码顺序执行

### 三、JVM
#### 1、内存空间，运行时数据区
- 虚拟机栈，Java栈：每个方法都会在栈内存中创建栈帧，用于存储局部变量
- 本地方法栈：类似虚拟机栈，为本地方法创建
- 堆：对象实例
- 程序计数器：线程私有，记录线程执行到哪里了
- 方法区（1.8实现为元空间[用的本地内存]，之前是永久代[跟堆连续在一起但又是隔离开的]）：类信息、常量、静态变量和编译后代码等数据（1.8字符串常量池和类静态变量都放到堆中了，因为不好指定大小和容易内存溢出，增加GC复杂度，回事效率低）

2、类加载过程
- 加载
- 验证
- 准备
- 解析
- 初始化

3、双亲委派机制
-  启动类加载器 BootstrapClassLoad  rt.jar
-  扩展类加载器 ExtClassLoad  ext目录下扩展jar
-  应用程序类加载器 AppClassLoad  claddpath上的类
-  加载机制：类加载器收到加载请求时，先委派给父类

4、GC垃圾回收
判断对象已死去的方法有引用计数法（已淘汰）和根搜索法（可达性分析算法）
- 标记-清除算法：先标记需要清除对象，遍历清除，容易产生内存碎片
- 复制算法：分两块内存，把存活对象复制到另一块内存上，再把第一块内存所有对象清除
- 标记-整理算法：将标记的存活对象都像一端移动，清理端边界以外的内存（老年代）
- 增量算法
- 分代收集算法：不同的代采用不同是算法。
	- 年轻代采用复制算法，因为大部分对象都是朝生夕死；
	- Eden区和From Survivor回收后存活对象复制到To Survivor
	- 默认15次没被回收的对象会被复制到Old区
	- Old区也被填满时，进行Full GC，对Old区进行垃圾回收
		
### 四、Linux命令

#### 1、新建用户
root登录系统，useradd 用户名，passwd 密码

#### 2、alias命令可查看和自定义别名
- 定义新的别名，比如 alias ll='ls -l' 
- 取消别名，比如 unalias ll

#### 3、which 搜索某个系统命令的位置
例  which ls

#### 4、whereis、locate和find
- whereis用于二进制文件程序名查找；locate是搜索文件数据库命令；find查找文件树命令
whereis 和 locate 都是基于系统内建的数据库进行搜索，效率高。而find是遍历硬盘查找文件