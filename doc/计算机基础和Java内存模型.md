### 一、计算机基础
#### 1、HTTP状态码
- 200 ok
- 204 No Content 请求成功，不包含实体
- 301 永久重定向
- 302 临时重定向
- 400 Bad Request 请求有语法错误
- 401 认证失败
- 403 请求拒绝
- 404 Not Found
- 500 服务器内部错误（程序异常抛出之类错误）
- 503 Service Unavailable 服务不可达（oom，栈溢出宕机等情况，无法处理请求）

#### 2、TCP三次握手和四次挥手（连接三次，断开四次）
##### 连接握手
- 第一步：客户端发送syn（同步应答编号）包到服务器，等确认
- 第二步：服务的收到syn包，确认syn并向客户端发送syn和ack（确认应答）包
- 第三步：客户端收到syn和ack包之后向服务端发送确认包ack，完毕双发进入ESTABLISHED（TCP连接成功）状态，完成三次握手
##### 关闭挥手
- 第一步：客户端发送FIN报文到服务端
- 第二步：服务端收到连接释放报文后发出确认ack
- 第三步：服务端若数据发送完毕了，发送FIN=1连接释放报文到客户端
- 第四步：

为什么：关闭连接时，服务端收到FIN报文后，不会立即关闭连接，只回复ACK报文，要等服务端全部报文发送完了知乎才发送FIN报文，所以多了一步

#### 3、进程、线程和协程区别
- 程序执行时的一个实例，进程至少包含一个线程，同进程里多个线程可容易共享数据，不同进程切换代价大
- 线程是cpu调度的最小单位，开销较小，是进程的一个实体
	
### 二、Java内存模型
#### 1、主内存和工作内存
规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成

#### 2、volatile禁止指令重排序，保证变量对所有线程的可见性
单例模式用到，new对象不是原子操作，分三步
- 分配内存空间
- 初始化对象
- 对象引用指向分配的地址  

由于cpu可能的优化排序，第三步可能会先与第二步执行，这时其他线程读到就会由问题，可用volatile禁止指令重排序避免此问题

#### 3、三个特性
- 原子性：一个操作中cpu不能中断，要么不执行，要么执行完成
- 可见性：多线程访问变量，一个线程修改了变量，其他线程能够立即看到修改值
- 有序性：按照代码顺序执行

### 三、JVM
#### 1、内存空间，运行时数据区
- 虚拟机栈，Java栈：每个方法都会在栈内存中创建栈帧，用于存储局部变量
- 本地方法栈：类似虚拟机栈，为本地方法创建
- 堆：对象实例
- 程序计数器：线程私有，记录线程执行到哪里了
- 方法区（1.8实现为元空间[用的本地内存]，之前是永久代[跟堆连续在一起但又是隔离开的]）：类信息、常量、静态变量和编译后代码等数据（1.8字符串常量池和类静态变量都放到堆中了，因为不好指定大小和容易内存溢出，增加GC复杂度，回事效率低）

#### 2、类加载过程
- 加载
- 验证
- 准备
- 解析
- 初始化

#### 3、双亲委派机制
-  启动类加载器 BootstrapClassLoad  rt.jar
-  扩展类加载器 ExtClassLoad  ext目录下扩展jar
-  应用程序类加载器 AppClassLoad  claddpath上的类
-  加载机制：类加载器收到加载请求时，先委派给父类

#### 4、双亲委派机制如何打破
- 自定义类加载器实现，重写自定义加载器的loadClass(),jdk不推荐。一般都只是重写findClass()，这样可以保持双亲委派机制.而loadClass方法加载规则由自己定义，就可以随心所欲的加载类了
- JDBC驱动例子，DriverManager在rt.jar，加载器是BootstrapClassLoader，JDBC驱动是三方开发，要由一般都指向AppClassLoader加载。Thread.currentThread().getContextClassLoader()和ClassLoader.getSystemClassLoader()一般都指向AppClassLoader，SPI用Thread.currentThread().getContextClassLoader()来加载实现类，实现在核心包里的基础类调用用户代码（使用线程上下文类加载器也就是应用程序类加载器来加载这些类）

#### 5、GC垃圾回收
判断对象已死去的方法有引用计数法（已淘汰）和根搜索法（可达性分析算法）
- 标记-清除算法：先标记需要清除对象，遍历清除，容易产生内存碎片
- 复制算法：分两块内存，把存活对象复制到另一块内存上，再把第一块内存所有对象清除
- 标记-整理算法：将标记的存活对象都像一端移动，清理端边界以外的内存（老年代）
- 增量算法
- 分代收集算法：不同的代采用不同是算法。
	- 年轻代采用复制算法，因为大部分对象都是朝生夕死；
	- Eden区和From Survivor回收后存活对象复制到To Survivor
	- 默认15次没被回收的对象会被复制到Old区
	- Old区也被填满时，进行Full GC，对Old区进行垃圾回收

#### 6、OOM相关
##### 堆溢出
- 1)内存泄漏（Memory Leak）：使用工具查看泄漏对象到GC ROOTS的引用链，找到泄漏对象是通过怎么样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们，准确地定位出泄漏代码的位置。
- 2)内存溢出(Memory overflow)：如果不是内存泄漏，换句话说，就是内存中的对象确实都还必须活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。
##### 栈内存溢出（-Xss）
- 1)如果线程请求的深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果栈的深度小或者栈针的容量比较大、用递归时，都可能引起。
- 2)如果是虚拟机在扩展时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。当使用多线程的时候，需要注意。
##### 方法区和运行时常量池溢出（-XX:PermSize -XX:MaxPermSize）
- 1)常量池中存放大量的String对象，并保持对这些对象的引用，避免Full GC回收常量池，就会产生OutOfMemoryError异常，后面跟的提示信息是“PermGen space”,说明运行时常量池属于方法区。
- 2)方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当产生大量的类去填充满方法区，就会溢出
- 3)Jdk1.8之后方法区由元空间替代，字符串常量池和类静态变量都放到堆中了，因为不好指定大小和容易内存溢出，增加GC复杂度，回事效率低
##### 本机直接内存溢出（-MaxDirectMemorySize）
DirectMemory容量可通过MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值一样。虽然DirectMemory内存溢出时也会抛出内存溢出异常，但它抛出的异常时并没有真正向操作系统申请内存分配，于是手动抛出异常。一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而且程序中又直接或者间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。

7、常见OOM和解决方法
- Java堆空间
	- 原因：无法在 Java 堆中分配对象；应用程序无意中保存了对象引用，对象无法被 GC 回收；应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长
	- 解决：使用 -Xmx 增加堆大小；修复应用程序中的内存泄漏
- GC 开销超过限制
	- 原因：Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。
	- 解决：使用 -Xmx 增加堆大小;使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制;修复应用程序中的内存泄漏
- Requested array size exceeds VM limit 应用程序试图分配一个大于堆大小的数组
	- 原因：应用程序试图分配一个超过堆大小的数组
	- 解决：使用 -Xmx 增加堆大小;修复应用程序中分配巨大数组的 bug
- Perm gen 空间
	- 原因：当 Perm gen 空间用尽时，将抛出异常。Perm gen 空间包含：类的名字、字段、方法；与类相关的对象数组和类型数组；JIT 编译器优化
	- 解决：使用 -XX: MaxPermSize 增加 Permgen 大小；不重启应用部署应用程序可能会导致此问题。重启 JVM 解决
- Metaspace 元空间
	- 原因：从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常
	- 解决：通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小；取消 -XX: maxmetsspacedize；减小 Java 堆大小,为 MetaSpace 提供更多的可用空间；为服务器分配更多的内存；修复bug
- unable to create new native thread 无法新建本机线程
	- 原因：内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足
	- 解决：将 heap 及 perm 的最大值下调，并将线程栈内存 -Xss 调小；修复应用程序中的线程泄漏；增加操作系统级别的限制
`ulimit -a`；用户进程数增大 (-u) 1800；使用 -Xss 减小线程堆栈大小
- 杀死进程或子进程
	- 原因：内核任务在可用内存极低的情况下会杀死进程
	- 解决：将进程迁移到不同的机器上；给机器增加更多内存；与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的
- 发生 stack_trace_with_native_method
	- 原因：本机方法（native method）分配失败；打印的堆栈跟踪信息，最顶层的帧是本机方法
	- 解决：使用操作系统本地工具进行诊断

### 四、Linux命令

#### 1、新建用户
root登录系统，useradd 用户名，passwd 密码

#### 2、alias命令可查看和自定义别名
- 定义新的别名，比如 alias ll='ls -l' 
- 取消别名，比如 unalias ll

#### 3、which 搜索某个系统命令的位置
例  which ls

#### 4、whereis、locate和find
- whereis用于二进制文件程序名查找；locate是搜索文件数据库命令；find查找文件树命令
whereis 和 locate 都是基于系统内建的数据库进行搜索，效率高。而find是遍历硬盘查找文件