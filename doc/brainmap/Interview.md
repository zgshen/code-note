# Interview

## 计算机基础

### 网络七层结构

#### 应用层

#### 表示层：定义数据格式和加密

#### 会话层：定义如何开始、控制和结束一个对话

#### 传输层：选择传输协议，并添加协议头如 TCP、UDP

#### 网络层

#### 数据链路层

#### 物理层

### HTTP 三次挥手和四次握手

### HTTP 状态码

#### 分类

##### 1XX 信息性状态码。接收的请求正在处理

##### 2XX 成功状态码。请求正常处理完毕

##### 3XX 重定向状态码。需要进行附加操作以完成请求

##### 4XX 客服端错误状态码。服务器无法处理请求

##### 5XX 服务器错误状态码。服务器处理请求出错

#### HTTP 状态码

##### 200 ok

##### 204 No Content 请求成功，不返回实体

##### 301 永久重定向

##### 302 临时重定向

##### 400 Bad Request 请求语法错误

##### 401 认证失败

##### 403 请求拒绝

##### 404 资源不存在

##### 500 服务器内部错误

##### 503 Service Unavailable 服务不可达

### HTTP 安全问题

#### 明文通讯

#### 不验证身份

#### 不验证数据完整性

### HTTPS 原理，非对称加密和混合加密算法

#### 通讯步骤

##### 客户端发情请求

##### 服务端将公钥证书返回客户端

##### 客户端验证公钥证书

##### 客户端使用随机数进行加密生成所使用的对称密钥，
然后用证书加密后发送给服务端

##### 服务端用私钥解密得到对称密钥

##### 服务端使用对称密钥加密明文内容，发送给客户端

##### 客户端使用对称密钥解密

#### SSL 功能

##### 加密（防窃听）

##### 认证（防伪装）

##### 完整性保护（防篡改）

### HTTPS 缺点

#### 需要加密解密

#### 证书费用

### 进程、线程和协程

#### 进程：程序执行时的一个实例，一个进程至少包括一个线程，
同进程里多个线程共享数据

#### 线程：cpu 调度的基本单位，线程上下文切换代价比进程小

#### 协程：一种用户态的轻量级线程，一个线程可包含多个线程。
进程和线程都是同步的，协程是异步的。

### Web 攻击方式和防范

#### XSS 跨站脚本攻击

#### CSRF 跨站请求伪造

#### SQL 注入

### 代理

#### 类型

##### 正向代理 用户察觉得到正向代理的存在。
例如内网机器通过代理访问公网。

##### 反向代理：一般位于内部网络中，用户察觉不到。
例如 nginx 反向代理多个服务。

#### 作用

##### 缓存

##### 负载均衡

##### 网络访问控制

##### 访问日志记录

## Java基础

### 面向对象

#### 三个特性

##### 封装：封装了数据和操作这些数据的逻辑实体

##### 继承：使用基类的属性和方法

##### 多态：类实例在不同情形下有不用的变现形式

#### 五大原则

##### 单一职责职责：单一功能，不做不关本类的事情

##### 开发封闭原则：对扩展开放，对修改封闭

##### 替换原则：子类可替换父类

##### 依赖倒置原则：使用抽象接口，不直接用实现类，实现类变化时不用改接口

##### 接口分离原则：模块之间通过抽象接口隔离，而不是用具体类耦合

### 反射

#### Java可以通过反射获取方法名称、方法参数和返回值类型等等，
但无法获取参数名称

#### 使用反射对类进行动态装配，降低代码耦合度。动态代理会使用到，
但过分使用或严重消耗系统资源

### 线程

#### 线程生命周期

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3f55f43-64c7-42c2-8fd4-1389f90a6f66/Untitled.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a3f55f43-64c7-42c2-8fd4-1389f90a6f66/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20201226%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20201226T162656Z&X-Amz-Expires=86400&X-Amz-Signature=ff8b5b4f38e546b453be5c8120ca7b9a122e220aced5f4d4ee7f6544862557a2&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。

- 新建：就是刚使用new方法，new出来的线程；
- 就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;
- 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;
- 阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;
- 销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;

##### 创建 new duixiang

##### 就绪 线程执行 start() 方法

##### 运行

##### 阻塞

##### 销毁

#### 创建线程方法

##### 继承 Thread 类重写 run() 方法

##### 实现 Runnable 接口的 run() 方法

##### 实现 Callable 接口，使用 FutureTask 类创建线程 

#### ThreadLocal 线程局部变量，同一个 ThreadLocal 所包含的对象，
在不同的 Thread 中有不同的副本。

##### 使用场景

###### JDBC连接池、存储session

##### 作用

###### 每个线程需要有自己单独的实例

###### 实例需要在多个方法中共享，但不希望多线程共享

##### 内存泄漏

ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value永远无法回收，造成内存泄漏。

其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。

###### 使用ThreadLocal的弱引用作为key，没用时会被回收，
但value不会

#### 线程池

### 集合框架

#### Collection接口

##### List

###### ArrayList 初始容量10，扩容1.5倍。非线程安全，随机查询快

###### Vector 线程安全，使用了 sychronized 

###### LinkedList 链表结构，新增和删除快

##### Set

###### HashSet 无序不重合集合

###### LinkedHashSet 基于hash实现的有序集合

###### TreeSet 基于红黑树实现的可排序集合

##### Queue 队列

#### Map 接口

##### AbstractMap

###### HashMap

####### 基本结构为 数组+链表/红黑树

####### 初始容量为16，负载因子0.75。若构造传入初始值n，
初始值大小为大于n的整数，且满足2的整数次方

####### 元素所在数组下标定位，hash函数实现

######## 先计算key的hashcode值，将高16位和低16位进行异或操作

######## 容量减1和hash进行取模确定数组下标值

####### 链表容量达到8会转成红黑树

####### 并发问题

######## 1.7 在多线程环境下，扩容时会造成环形链或数据丢失

######## 1.8 在多线程环境下，会发生数据覆盖的情况

####### 1.8较1.7优化部分

######## 数组+链表结构改为数组+链表/红黑树，
时间复杂度由链表O(n)降低为红黑树O(logn)

######## 链表的插入方式由头插法改成了尾插法。头插法可能会造成环形链

###### LinkedHashMap 双向链表，元素默认按插入顺序排序

###### TreeMap 红黑树实现。默认按照 key 值升序排序，可指定排序比较器

###### Hashtable 线程安全，方法上加了 synchronized

##### SortedMap

###### TreeMap

##### ConcurrentHashMap

###### 变量使用 volatile 修饰

###### 使用CAS操作和synchronized结合实现赋值操作

### 异常处理

#### Error 和 Exception

#### 运行时异常和受检异常

#### 常见运行时异常

#### final、finally和finalize

#### throw 和 throws

### 锁

#### Java 实现

##### sychronized 关键字

##### Lock 接口

#### 乐观锁和悲观锁

#### 自旋锁和适应性自旋锁

##### 自适应意味着自旋的时间（次数）不再固定，
而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

#### 无锁、偏向锁、轻量级锁和重量级锁

##### 轻量级锁自旋实现

#### 公平锁 VS 非公平锁

##### 公平锁：队列排队执行，其他线程全部堵塞，cpu唤醒线程代价大

##### 非公平锁：CPU不必唤醒所有线程。缺点是处于等待队
列中的线程可能会饿死，或者等很久才会获得锁

#### 可重入锁和不可重入锁

##### status 值，线程占有加1，不可重入判断 satus 值来决定能不能拿到锁

#### 独享锁和共享锁

## JVM

### 类加载步骤

#### 加载

##### 获取类的二进制字节流

##### 将字节流代表的静态存储结构转化为方法区运行时的数据结构

##### 在堆中生成 class 字节码对象

#### 验证：验证 class 文件字节流包含的信息符合当前虚拟机要求

#### 准备：为类的静态变量分配内存并将其初始化为默认值

#### 解析：虚拟机将常量池内符号引用替换成直接引用的过程

#### 初始化：执行类构造器的初始化过程

### 类加载机制

#### 类加载器

##### 启动类加载器（Bootstrap ClassLoader）
负责加载 <JRE_HOME>\lib 目录中的类库，如 rt.jar

##### 扩展类加载器（Extension ClassLoader）
负责加载 <JRE_HOME>\lib\ext 目录中类库

##### 应用类加载器（Application ClassLoader）
负责加载用户路径下的类库

#### 双亲委派机制：一个类加载器首先将类加载请求转发到父类加载器，
只有当父类加载器无法完成时才尝试自己加载。

#### 如何打破双亲委派机制 

##### 自定义类加载器

##### 数据库驱动例子

### JVM 内存模型

#### 类加载器子系统

#### 运行时数据区

#### 执行引擎

### 运行时数据区

#### 虚拟机栈：每个 Java 方法在执行过程的同时会创建一
个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。

#### 本地方法栈：与虚拟机栈相似，区别只是为本地方法服务的

#### 程序计数器：记录正在执行的虚拟机字节码指令的地址

#### 堆：存储对象实例

#### 方法区：用于存放已被记载的类信息、常量、静态变量和编译后的代码等数据。

#### +运行时常量池：方法区的一部分， Class 文件中的常量池（编译时生成的字面量和符号引用）
会在类加载后被放入这个区域

#### +直接内存：一些 Native 函数直接分配对外内存

### 垃圾回收判断

#### 引用计数算法：引用数为0的对象回收，难以解决对象循环引用问题

#### 根搜索法（可达性算法）：从 GC Root 对象开始向下搜索，
可达的对象都是存活的，不可达的对象无法被回收

### 垃圾回收算法

#### 标记-清除

#### 标记-整理

#### 复制

#### 分代收集

##### 新生代使用复制算法

##### 老年代使用标记-清除或者标记-整理算法

### 垃圾回收器

https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6

#### Serial 收集器

#### ParNew 收集器

#### Parallel Scavenge 收集器

#### Serial Old 收集器

#### Parallel Old 收集器

#### CMS 收集器

#### G1 收集器

### 内存分配与回收策略

#### Minor GC 和 Full GC

##### Minor GC：回收新生代，因为新生代对象存活时间很短，因此会频繁执行，速度较快

##### Full GC：回收老年代和新生代，老年代对象存活时间长，因此 Full GC 很少执行，
执行速度会比 Minor GC 慢很多

#### 内存分配策略

##### 对象有限在 Eden 分配

##### 大对象直接进入老年代

##### 长期存活的对象进入老年代

##### 动态对象年龄判定

##### 空间分配担保

#### Full GC 触发条件

##### 调用 System.gc()

##### 空间分配担保失败

##### JDK1.7 以前的永久代空间不足

## 第三方工具

### Spring

#### 组成

##### Spring Core 框架核心，提供 IOC 容器，管理 bean 对象

##### Spring Context 提供上下文信息

##### Spring Dao 提供 JDBC 抽象层

##### Spring ORM 提供“对象/关系”映射 APIs 的集成层

##### Spring AOP 切面编程功能

##### Spring Web 提供 web 开发的上下文信息

##### Spring Web MVC 提供了 web 应用的
model-view-controller 实现

#### IOC 和 AOP

##### IOC 控制反转，将对象交给 Spring IOC 容器控制，
而不是显式地用代码创建对象。DI 依赖注入是它的实现

##### AOP 面向切面编程（@Aspect @ControllerAdvice）

###### 动态代理（jdk动态代理，cglib 动态代理）

###### 静态织入

#### 常用注解

##### bean 定义注解

###### @Component 描述Spring框架中的bean

###### @Repository 用于对DAO实现类进行标注

###### @Service 用于对业务类进行标注

###### @Controller 用于对控制类进行标注

##### 属性注入

###### @Autowired 自动注入

###### @Autowired(required=true) 找到匹配的bean

###### @Qualifier 可指定 bean 名称，用于多个同接口实现

###### @Resource 是 jdk 注解，与@Autowired 类似

##### 其他

###### @PostConStruct() 初始化

###### @PreDestory() 销毁

###### @Scope() 指定作用域

###### @Profile() 指定环境 bean 生效

#### 用到哪些设计模式

常用设计模式 https://www.cnblogs.com/kyoner/p/10949246.html

- 工厂模式：Spring使用工厂模式可以通过 `BeanFactory` 或 `ApplicationContext` 创建 bean 对象；
- 单例模式：Spring中bean的默认作用域就是singleton(单例)的；
- 代理模式：Spring AOP就是基于动态代理的；
- 观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用。`ApplicationListener` 监听器；
- 适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller；
- 模版方法模式：Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式；
- 装饰者模式

##### 单例

##### 动态代理

##### 工厂

##### 适配器

##### 观察者

##### 装饰者

##### 模版

### Redis

#### 基本数据类型

- string 字符串。常用命令 set,get,decr,incr,mget 等。常用在缓存、计数、共享Session、限速等；
- hash 哈希。常用命令 hget,hset,hgetall 等。哈希类型是指键值本身又是一个键值对结构。哈希可以用来存放用户信息，比如实现购物车；
- list 列表。常用命令 lpush,rpush,lpop,rpop,lrange 等。列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。另外，可以利用 lrange 命令，做基于 Redis的分页功能，性能极佳；
- set 集合。常用命令 sadd,spop,smembers,sunion 等。集合中不允许有重复元素，且元素是无序的。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能；
- zset(sorted set) 有序集合。常用命令 zadd,zrange,zrem,zcard 等。多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。

##### 字符串 String

##### 列表 List

##### 哈希 Hash

##### 集合 Set

##### 有序集合 Zset（sorted set）

#### 持久化方式

- RDB 半持久化，每隔一段时间进行持久化，只有一个dump.rdb文件，容灾好，恢复容易，但故障容易丢失数据；
- AOF 日志追加方式，不容易丢失数据，但持久化文件较大，恢复慢。

##### RDB 每隔一段时间持久化

##### AOF 日志追加

#### 主从、哨兵和 cluster 集群

- 主从：分摊读压力，主节点故障可根据其他节点恢复
- 哨兵：高可用，主节点故障时从节点竞选出新的主节点
- cluster 集群：数据切割分布到各个节点hash槽上，通过分节点主从和分区提供一定高可用
    - 可以如何寻址？使用哈希一致性算法。将整个哈希值空间组织成一个虚拟圆环，根据各个服务器ip或主机名作为关键字进行哈希计算确定其在哈希环位置。key对应哈希值从环顺时针滚动确定key放在哪台服务器上，碰到挂了的服务器区间会跳过，保存在下一个环位置对应的服务器，提高了**容错性**。同时增加节点干扰的数据也少，提高了**扩展性。**
    - Redis 集群没有使用一致性 hash，而是引入了**哈希槽**的概念
    - Redis 集群有 16384 个哈希槽，每个 key 通过 **CRC16 算法**计算的结果，对 16384 取模后放到对应的编号在 0-16383 之间的哈希槽，集群的每个节点负责一部分哈希槽
    - 如何动态增加或删除一个节点

        ./redis-trib.rb add-node 移动哈希槽到新节点

        ./redis-trib.rb del-node 移动哈希槽到其他节点并删除该节点

##### 主从：分摊读写压力

##### 哨兵：高可用

##### cluster 集群：兼顾两者

#### 缓存穿透、击穿和雪崩

- 缓存穿透：key对应的数据在数据源并不存在，从缓存获取不到，请求都会到数据源，从而可能压垮数据源。采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力；或者查询返回的数据为空仍然进行缓存，过期时间设置较短。
- 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，从后端DB加载数据并回设到缓存，数据库压力大。使用互斥锁(mutex key)SETNX。缓存失效的时候，不立即去load db，而是去set一个mutex key，成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。
- 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件

##### 穿透：key 不存在，压力到数据库

##### 击穿：key 失效，大量并发请求压力到数据库

##### 雪崩：大量 key 同一时间段失效，数据库压力大 

#### 分布式锁实现

##### 使用 setnx 命令，抢占锁，记录线程id，解锁须判断线程再清除 key
必须设置失效时间防止操作失败一直占着锁

##### 使用框架 Redisson

#### 消息队列实现方式

https://www.cnblogs.com/-wenli/p/12777703.html

##### 基于异步消息队列 List lpush-brpop(rpush-blpop)

###### 使用rpush和lpush操作入队列，lpop和rpop操作出队列

###### 当队列为空时，lpop和rpop会一直空轮训，消耗资源；
所以引入阻塞读blpop和brpop（b代表blocking），阻塞读在队列没有数据的时候进入休眠状态

##### PUB/SUB 订阅/发布模式

###### SUBSCRIBE，用于订阅信道

###### PUBLISH，向信道发送消息

###### UNSUBSCRIBE，取消订阅

##### 基于 sorted set 的实现

###### zadd 添加带分数元素

###### zrange或zrevrange返回有序集合，指定区间的成员。
使用0，0区间来获取处于顶部的元素

###### zrem 移除元素，消费后移除

##### 基于 stream 类型的实现。stream 是redis 5.0后新增的数据结构

#### 延迟消息实现

##### 利用 zadd 和 zrangebyscore 来实现存入和读取消息

#### Sortes Set(有序列表)实现，压缩列表和跳表

##### 压缩列表 ziplist

###### 有序集合保存的元素数量小于128个

###### 有序集合保存的所有元素的长度小于64字节

##### 跳表 skiplist

###### 一种基于有序链表的扩展，跳表会维护多个索引链表和原链表

###### 查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)

###### 跳表是一种随机化的数据结构(通过抛硬币来决定插入层数)

###### 空间复杂度为 O(n)

#### 一致性哈希和哈希槽

##### 一致性哈希（一致性hash是一个0-2^32的闭合圆）

###### 用于解决分布式缓存系统中的数据选择节点存储问题
和数据选择节点读取问题
以及在增删节点后减少数据缓存的消失范畴，防止雪崩的发生。

###### 顺时针找到归属的节点

##### 哈希槽（redis cluster一共有2^14=16384个槽）

###### redis cluster集群没有采用一致性哈希方案，
而是采用数据分片中的哈希槽来进行数据存储与读取的。

###### 根据CRC-16(key)384的值来判断属于哪个槽区，
从而判断该key属于哪个节点

### MQ

#### 常用mq有哪些

##### RabbitMQ

##### RocketMQ 支持分布式事务

##### Kafka 

###### 一般用于大数据系统实时运算，日志采集

###### 功能简单，可靠性高，扩展性高

###### 缺点是可能导致重复消费

##### ActiveMQ

#### 主要作用

##### 削峰限流

##### 异步处理

##### 应用解耦

#### 使用场景

##### 秒杀抢购场景流量削峰，入队列，超过最大长度丢弃

##### 异步处理和解耦。如注册用户发邮件验证，
提交MQ由业务模块消费，同时将两个模块解耦

##### 日志采集，常用 kafka

##### 消息通讯。点对点或发布/订阅模式。

#### 带来的问题

##### 系统可用性降低，挂掉影响其他系统

##### 系统复杂度变高，须考虑消息丢失和重复消费问题

##### 一致性问题，多个系统消费有的成功有的失败问题

#### 高可用方法

##### RabbitMQ 镜像集群，多节点复制 queue 节点信息

##### ActiveMQ 部署主从热备

##### RocketMQ 有多 master 多 slave 异步复制模式和
多 master 多 slave 同步双写模式支持集群部署模式

#### 问题

##### 确保消息不丢失

###### 生产者：使用确认或事务机制。
如 RabbitMQ 的事务模式和 confirm 模式

###### MQ内部出错、宕机等情况。 开启MQ持久化配置

###### 消费者 一般默认是自动确认模式，防止消费者取到消息挂掉了，
改为使用手动确认模式

##### 避免重复消费

###### 给消息生成全局唯一id（可用Redis），消费成功的可丢弃

###### 消息带上数据库唯一字段数据，避免重复插入

##### 消息挤压如何处理

###### 扩容，启用多个消费者，并发接收消息，持久化后再处理，
或者直接丢弃消息，回头让生产者重新生产

###### 若短时间无法扩容，将系统降级，减少发送的数据量

###### 监控发现，若生产消费速度没什么变化，但消息挤压，
检查是否有消费失败反复消费情况

###### 监控发现，消费消息速度慢，检查消费实例是否有消费
错误，是否有死锁或资源堵塞

#### 如何保证消费顺序

##### 生产者保证消息入队的顺序

##### MQ 本身是一种先进先出的数据接口，将同一类信息，
发送到同一个 queue 中，保证出队是有序的

##### 避免多消费者并发消费同一个 queue 中的消息，
最好一个消费者对应一个 queue

### Elasticsearch

#### 与关系型数据库区别

##### 关系型数据库：数据库 => 表 => 行 => 列

##### Elasticsearch：索引 => 类型 => 文档 => 字段

#### 分布式search

##### 查询流程分为query和fetch两个阶段

##### 查询和计算权重得分在Lucene完成，聚合是在ES中实现的

## 微服务 

### 好处

#### 针对特定服务发布，影响小，风险小，成本低

#### 频繁发布版本，快速交付需求

#### 低成本扩容，弹性伸缩，适应云环境

### 坏处

#### 分布式系统比较复杂

#### 部署，测试和监控的成本高

#### 有分布式事务和CAP的相关问题

### Spring Cloud

#### 常用组件

##### 注册中心

###### Eureka

###### Zookeeper

###### Consul

###### Nacos

##### 配置中心 Spring Config

###### git webhook 事件处理，调用配置链接通知配置中心

###### 配置中心发送消息到 mq，mq下发消息到各个服务

###### 各个服务更新修改后的配置

##### 网关

###### Spring Gateway

###### Zuul

##### 客户端负载均衡 Ribbon

默认使用算法是lun'xu

##### 断路器 Hystrix

##### RPC 客户端 Feign

涉及的涉及模式有哪些，是如何实现d

###### 动态代理模式

### 限流方法（流量控制、熔断降级、系统负载保护）

#### Hystrix 熔断策略基于异常比率；
限流基于  QPS，支持基于调用关系的限流

#### sentinel  熔断策略基于响应时间、异常比率、异常数；
限流支持有限（并发线程数或信号量大小）

#### Redis + Lua 脚本

##### 判断 key 是否存在，若不存在设置 key 过期时间和对应 value 为1；
若存在判断在过期时间内 key 对应的 value 值是否大于限制数量；
大于返回 false；
小于自增加2并返回 true。

### 限流算法

#### 计数器

#### 滑动窗口（Sentinel）

#### 漏桶（Java 线程池）

#### 令牌桶（Guava RateLimiter）

### 负载均衡算法

#### 随机

#### 轮询

#### 加权响应：响应时间短的权重就大

### 分布式锁

#### 数据库级别：读频繁用客观锁，写频繁用悲观锁

##### 乐观锁：基于版本号实现

##### 悲观锁：基于数据库级别的for update

#### 基于 Redis 原子性操作

##### 基于 setnx 和 expire 实现

#### 基于 Rdisson 框架实现

#### 基于 Zookeeper 实现

##### 基于 InterprocessMutex 实现

### 分布式事务

分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。

#### CAP理论：一致性、可用性和分区容错在分布式事务中不可兼得。

##### 一致性（Consistency）

##### 可用性（Availability）

##### 分区容错性（Partition tolerance）

#### BASE 理论

##### Basically Available（基本可用）

##### Soft state（软状态）

##### Eventually consistent（最终一致性）

#### 常见解决方案

##### 基于 XA 协议的 2PC（两段提交） 和 3PC

###### Seata 常用模式

##### 基于业务层的 TCC

###### Try Confirm Cancel 三阶段，代码实现复杂度相对较高

##### 应用消息队列 + 本地消息表实现的最终一致性方案

###### 目前市面上支持该方案的 mq 只有阿里的 rocketmq，
单消息队列可用于：

####### 用户注册成功后发送邮件

####### 电商系统给用户发送优惠券

###### 跨行转账可通过该方案实现

##### 最大努力通知

###### 例如支付回调和其他一些回调通知

#### 框架

##### Seata：提供 AT、TCC、SAGA 和 XA 事务模式

##### TX-LCN：提供LCN（2pc）、TCC、TXC 三种事务模式

##### Raincat 

#### Seata 4种事务模式

常见分布式事务解决方案
1、seata 阿里分布式事务框架
2、消息队列
3、saga
4、XA
他们有一个共同点，都是“两阶段”。“两阶段”是指完成整个分布式事务，划分成两个步骤完成。

实际上，这四种常见的分布式事务解决方案，分别对应着分布式事务的四种模式：AT、TCC、Saga、XA；

四种分布式事务模式，都有各自的理论基础，分别在不同的时间被提出；每种模式都有它的适用场景，同样每个模式也都诞生有各自的代表产品；而这些代表产品，可能就是我们常见的(全局事务、基于可靠消息、最大努力通知、TCC)。

（AT、TCC、Saga、XA）模式分析
四种分布式事务模式，分别在不同的时间被提出，每种模式都有它的适用场景

- AT 模式是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本。
- TCC 模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。
- Saga 模式是长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁，长流程情况下可以保证性能，多用于渠道层、集成层业务系统。事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，也可以使用 Saga 模式。
- XA模式是分布式强一致性的解决方案，但性能低而使用较少。

作者：消失er
链接：https://www.jianshu.com/p/75217db81c99
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### AT：AT模式是一种无侵入的分布式事务解决方案。
阿里seata框架，实现了该模式。

##### TCC：TCC 模式需要用户根据自己的业务场景实现 Try、Confirm 和 Cancel 三个操作；
事务发起方在一阶段执行 Try 方式，在二阶段提交执行 Confirm 方法，二阶段回滚执行 Cancel 方法。

##### Saga：Saga 模式适用于业务流程长且需要保证事务最终一致性的业务系统，
Saga 模式一阶段就会提交本地事务，无锁、长流程情况下可以保证性能。

##### XA：XA是X/Open DTP组织（X/Open DTP group）定义的两阶段提交协议。
X/Open DTP模型（1994）包括应用程序（AP）、事务管理器（TM）、资源管理器（RM）。

### 分支主题

### 链路追踪

sleuth: 为我们生成了请求链路信息，虽然我们已经可以通过Trace ID来跟踪整体请求链路了，但是我们还是得去各个系统中捞取日志。在并发较高得时候，日志是海量的，这个时候我们可以借助zipkin来代替我们完成日志获取与分析。

zipkin: 主要有四个组件，可以帮助我们收集由sleuth产生的请求链路信息，并保存到MySQL或者Elasticsearch中，并通过web页面分析与跟踪请求日志。这里提一句：最新版本的zipkin还不支持6.0.0以上版本的Elasticsearch。

Collector：收集器，负责收集日志信息，以供后续的存储，分析与展示；
Storage：存储模块，我们可以通过它将日志存储到MySQL或者Elasticsearch中。
RESTful API：API组件，它主要用来提供外部访问接口。 比如给客户端展示跟踪信息，或是外接系统访问以实现监控等；
WEB UI：通过web页面，我们可以轻松的分析与跟踪请求日志。

#### Spring Cloud Sleuth

#### ZipKin

### 分布式 id 生成方式

#### UUID

#### 数据库自增 ID

#### 数据库多主模式

#### 号段模式

#### Redis

#### 雪花算法

## 数据库

### 数据库三范式

- 列不可分，确保表的每一列都是不可分割的原子数据项。作用：方便字段的维护、查询效率高、易于统计。
- 属性字段完全依赖（完全依赖指不能存在仅依赖主键的部分属性）于主键。作用：保证每行数据都是按主键划分的独立数据。
- 任何非主属性字段不依赖于其它非主属性字段。作用：减少表字段与数据存储，让相互依赖的非主键字段单独成为一张关系表，记录被依赖字段即可。

三大范式只是一般设计数据库的基本理念，可以设计冗余较小、存储查询效率高的表结构。

但不能一味的去追求数据库设计范式，数据库设计应多关注需求和性能，重要程度：需求 - 性能 - 表结构。比如有时候添加一个冗余的字段可以大大提高查询性能。

#### 列不可分，确保表的每一列都是不可分割的原子数据项

#### 属性字段完全依赖（完全依赖指不能存在仅依赖主键的部分属性）于主键

#### 任何非主属性字段不依赖于其它非主属性字段

### 五大约束

#### 主键约束：唯一，非空

#### 唯一约束：唯一，可为空，但也只能有一个

#### 默认约束

#### 外键约束

#### 非空约束

### ACID  原则，事务的四个特性

事务的四大特性
事务具备ACID四种特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。

- 原子性（Atomicity）
	事务最基本的操作单元，要么全部成功，要么全部失败，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。

- 一致性（Consistency）
	事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

- 隔离性（Isolation）
	指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

- 持久性（Durability）
	指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。
    
    
简单点的说法
- 原子性(atomicity)：一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作（只管成功与否，不管是否正确）；
- 一致性(consistency)：确保了任何事务都会使数据库从一种合法的状态变为另一种合法的状态（数据库各种约束规则起作用，代码自己实现保证符合逻辑，比如转账不能超出余额）；
- 隔离性(isolation)：并发环境下，每个事务都有各自完整的数据空间，修改隔离，数据要么是修改前的状态，要么是修改后的状态，不能是中间的状态。
- 持久性(durability)：事务成功，对数据库的操作必须永久保存下来，必须生效。即使系统奔溃，能恢复到事物成功后的状态。

#### 原子性

#### 一致性

#### 隔离性

#### 持久性

### 事务隔离级别

- 读未提交：另一个事务能看到这个事务未提交的数据。脏读、幻读、不可重复读；
- 读提交：事务提交后才能被另一个事务读到。避免了脏读。大多数数据库模式隔离级别；
- 可重复读：保证一个事务不能被另外一个事务读取未提交的数据之外，还避免了不可重复读，但不能避免幻读，比如第二次会读到新增的行（MySQL默认隔离级别，幻读使用mvvc版本并发控制解决了）；
- 序列化：事务顺序执行，最高隔离级别。

#### 读未提交

#### 读已提交

#### 可重复读

#### 串行化（序列化）

### 事务传播机制

- REQUIRED 如果当前方法没有事务则加入事务,没有则创建一个事务（**Spring默认的事务传播类型**）
- NOT_SUPPORTED 不支持事务,如果当前有事务则挂起事务运行
- REQUIREDS_NEW 新建一个事务并在这个事务中运行,如果当前存在事务就把当前事务挂起,新建的 事务的提交与回滚一挂起事务没有联系,不会影响挂起事务的操作
- MANDATORY 强制当前方法使用事务运行,如果当前没有事务则抛出异常
- NEVER 当前方法不能存在事务,即非事务运行,如果存在事务则抛出异常
- SUPPORTS 支持当前事务,如果当前没事务也支持非事务状态运行
- NESTED 如果当前存在事务,则在嵌套事务内执行,嵌套事务的提交与回滚与父事务没有任务关系,反之,当父事务提交嵌套事务也一起提交,父事务回滚会也回滚嵌套事务的,如果当前没有事务,则新建一个事务运行.

#### REQUIRED 如果当前方法没有事务则加入事务,没有则创建一个事务
（Spring默认的事务传播类型）

#### NOT_SUPPORTED 不支持事务,如果当前有事务则挂起事务运行

#### REQUIREDS_NEW 新建一个事务并在这个事务中运行,
如果当前存在事务就把当前事务挂起

#### MANDATORY 强制当前方法使用事务运行,如果当前没有事务则抛出异常

#### NEVER 当前方法不能存在事务,即非事务运行,如果存在事务则抛出异常

#### SUPPORTS 支持当前事务,如果当前没事务也支持非事务状态运行

#### NESTED 如果当前存在事务,则在嵌套事务内执行

### 聚簇索引和非聚簇索引

- 索引与行记录是分开存储的，叫做非聚簇索引。比如 MyISAM 索引都是非聚簇索引，其主键索引与普通索引没有本质差异；
- 聚簇索引，有且只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储。InnoDB 主键索引与行记录是存储在一起的，没有主键索引，则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的id来当作主键索引。

延迟关联应用场景有关

#### 聚簇索引：将数据存储与索引放到了一块，数据实际上存放在索引的叶子节点上，
一个表只能有一个聚簇索引

#### 非聚簇索引：数据存储与索引分开，索引结构的叶子节点指向了数据的对应行

### B树和B+树区别

#### B-树

##### 所有键值分布在整颗树中（索引值和具体data都在每个节点里）

##### 任何一个关键字出现且只出现在一个结点中

#####  搜索有可能在非叶子结点结束
（最好情况O(1)就能找到数据，找到自然就结束了，不需要一直到叶子结点）；

##### 在关键字全集内做一次查找,性能逼近二分查找

#### B+树

#####  所有关键字存储在叶子节点出现,内部节点(非叶子节点)并不存储真正的 data

#####  为所有叶子结点增加了一个链指针

### 哈希索引和B+树索引区别

#### B+树是一个平衡的多叉树，从根节点到叶子节点逐级查找

#### 哈希索引是采用一定的哈希算法，把键值换算成新的哈希值，
只需一次哈希算法即可立刻定位到相应的位置

#### 如果是等值查询，那么哈希索引明显有绝对优势

#### 如果是范围查询检索，哈希索引也没办法利用索引完成排序

#### 大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了

### explain 执行计划

#### 作用

##### 表加载顺序

##### sql 查询类型

##### 分析索引应用

##### 多少行被优化器查询

#### 包括

##### id：查询优先级，越大优先级越高，相同时有优化器决定

##### select_type：查询类型，如普通查询、联合查询和子查询

###### SIMPLE：普通类型

###### PRIMARY：查询语句包含任何子部分，最外层查询就被标记为 PRIMARY

###### SUBQUERY：当 select 或 where 包含了子查询，该子查询被标记为SUBQUERY

###### DERIVED：包含在 from 子句中的子查询就会被标记为 DERIVED

###### UNION：若第二个SELECT出现在UNION之后，则被标记为UNION

###### UNION RESULT：从UNION表获取结果的SELEC

##### talbe：表名，不一定是真实存在的表，有别名显示别名，也有可能是临时表

##### partitions：查询匹配到的分区信息，对于非分区表值为 null，
当查询分区表时，partitions 显示分区表命中的分区情况

##### type：查询使用的类型，性能从好到坏是 system > const > eq_ref > ref > ref_or_null > 
index_merge > unique_subquery > index_subquery > range > index > ALL

###### null：不需要访问任何表和索引，直接返回结果

###### const/system：单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询

###### eq_ref：常出现于关联查询，使用主键或唯一索引

###### ref：区别于 eq_ref ，表示使用非唯一性索引，可能会找到多个符合条件的行

###### ref_or_null：类似于 ref ，区别是会额外搜索包含 NULL 的行

###### index_merge：使用了索引合并优化方法，查询使用了两个以上的索引

###### unique_subquery：替换了形式value IN (SELECT primary_key FROM X)的IN子查询的ref

###### index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值

###### range：只检索给定范围的行，使用一个索引来选择行

###### index：Index 与ALL 其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取

###### ALL：将遍历全表以找到匹配的行，性能最差

##### ref：常见的有const，func，null，字段名

当使用常量等值查询，显示const，
当关联查询时，会显示相应关联表的关联字段
如果查询条件使用了表达式、函数，或者条件列发生内部隐式转换，可能显示为func
其他情况null

##### rows：表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数

##### filtered：百分比的值，表里符合条件的记录数的百分比。
简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例

##### Extra：不适合在其他列中显示的信息，Explain 中的很多额外的信息会在 Extra 字段显示

#### 数据库优化

##### 服务器优化

###### 调整查询缓存配置参数，可调大到内存80%

###### 开启 sql 慢查询日志

##### sql 优化

###### 尽量只查必要的字段，而不是使用 select *

###### 注意索引的使用，失效或者查询数据量大

###### 大表 join 小表

### MyISAM 和 InnoDB区别

#### MyISAM 是非事务安全的，InnoDB 是事务安全的

#### MyISAM 锁粒度是表级的，而 InnoDB 支持行级锁

#### MyISAM 支持全文索引，而 InnoDB 不支持

#### MyISAM 相对简单，效率上由于 InnoDB，如果应用执行大量 select 操作适合使用

#### InnoDB 支持事务管理，具备 ACID 事务特性，如果应用需要大量 insert 和 update 操作适合使用

## 开放问题

### 如何理解高并发

#### 并发与并行

##### 并行：系统可以同时处理多个任务。同时进行，不抢占 cpu，不需要线程切换

##### 并发：系统在一段时间内可以处理多个任务。短时间内 cpu 交替执行，处理多个任务

#### 提高并发能力

##### 水平扩展

###### 分布式，增加服务器数量

###### 实践

####### 反向代理层使用 DNS 轮询进行水平扩展

####### 站点使用 nginx 进行水平扩展

####### 服务层使用服务连接池进行水平扩展

####### 数据库使用哈希的方式进行水平扩展

##### 垂直扩展

###### 增强单机性能

###### 提升单机架构性能，如使用缓存、异步和无锁结构减少响应时间

### CPU 占用高如何排查

#### top 命令看占用高的进程pid
free 查看内存占用
dr 查看硬盘占用

#### jstack 查看线程堆栈信息，分析线程状态。
查看是否有堵塞死锁情况。
jstack pid > jstack.log

#### 可以再找到线程 tid
jstack pid |grep tid 查看具体线程的堆栈信息

#### 分支主题

#### jstat 查看 GC 日志，看看 GC 是否频繁，是否有
Full GC 情况

#### jmap -dump:format=b,file=heap.hprof pid
保存堆现场
用工具分析，如JVisualVM、MAT、JProfiler等

### OOM 如何排查

#### 堆OOM，调整  -Xmx 大小

#### 本地内存 OOM，压测线程创建过多占满内存，减少线程池最大线程数，减小堆内存

#### 扩展：栈溢出（比如递归）

##### 线程请求深度大于虚拟机深度，StackOverflowError

##### 虚拟机扩展时无法申请到足够内存，OutOfMemoryError

### 内存泄漏可能表现情况

如果具有满足一下两个条件的对象：
1）对象是可达的。即在有向图中，存在通过达到该对象，GC不会回收。
2）对象的无用的。即程序以后不会再使用这些对象。
那么这些对象是无有，但是占用着内存空间，并且不会被GC回收这就是所谓的内存泄漏。

如果内存泄漏非常严重的话，最终会导致内存溢出。

#### OOM 异常

#### 内存持续上升

#### 频繁 Full GC

### 数据库调优

#### 服务器层面优化，参数调整

##### 根据应用接入设置最大链接数量，一般设个3000

##### innodb_buffer_pool_size 缓冲区大小，设为系统内存约80%

##### 开启慢查询日志，便于定位和监控慢查询 sql

#### 数据库设计层面，表设计和结构选择

##### 表设计字段的类型选择，长度设置，适当冗余部分字段减少关联表查询

##### 使用读写分离

##### 分表分库

##### 根据业务创建合理的索引

###### 数据唯一性差的字段不适合建索引

###### 频繁更新的字段不适合建索引

###### 不在 where 后面作为查询条件的不加索引

#### 数据库执行层面，优化 sql 语句，合理使用索引

##### 尽量使用主键查询

##### 尽量使用单表查询而不是关联表

##### 优化 sql 语句，使用 explain 查看执行计划并分析

###### 只需要少量字段时候不用 select *

###### 关联语句一般是小表关联大表

###### 防止索引失效

####### 索引遵循最左匹配原则，只有在查询条件中使用了创建索引时的第一个字段，
索引才会被使用，使用复合索引时遵循最左前准集合

####### <>/ is NULL/ is NOT NULL /Like 等关键字会使索引失效

####### or 要使用索引必循每个条件字段都有索引

####### where 子句索引列上有使用函数运算，索引也会失效

#### 系统架构层面增强补充

##### Redis

##### Memcached

#### 开发编码层面

##### 使用数据库连接池

##### 使用批量操作

## 设计模式

### 单例模式

### 工厂模式

### 观察者模式

### 建造者模式

### 代理模式

### 适配者模式

### 装饰者模式

### 命令模式

### 策略模式

### 组合模式

### 享元模式

### 状态模式

## 算法与数据结构

### 算法

#### 排序算法

#### 贪心

#### 递归

#### 二分法

#### 动态规划

#### 跳表

### 数据结构

#### 数组

#### 链表

##### 跳表

##### 双向链表

#### 队列

#### 哈希表

#### 树

##### 二叉树

##### 红黑树

#### 图

#### 堆

##### 最小堆最大堆

#### 栈
