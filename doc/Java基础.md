
## 一、基本概念
### 1.JDK和JRE有什么区别？
- JRE：Java Runtime Environment（ java 运行时环境）。即java程序的运行时环境，包含了 java 虚拟机，java基础类库。
- JDK：Java Development Kit（ java 开发工具包）。即java语言编写的程序所需的开发工具包。JDK 包含了 JRE，同时还包括 java 源码的编译器 javac、监控工具 jconsole、分析工具 jvisualvm等。

### 2.对面向对象的理解
对象有以下特点：
- 对象具有属性和行为
- 对象具有变化的状态
- 对象具有唯一性
- 对象都是某个类别的实例
- 一切皆为对象，真实世界中的所有事物都可以视为对象

面向对象的特性：
- 抽象性：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。
- 继承性：指子类拥有父类的全部特征和行为，这是类之间的一种关系。Java 只支持单继承。
- 封装性：对象是一个封装了数据以及操作这些数据的逻辑实体。封装的目的在于保护信息。
- 多态性：多态性体现在父类的属性和方法被子类继承后或接口被实现类实现后，可以具有不同的属性或表现方式。

### 3.Java设计模式六大原则
- 单一职责原则：功能单一，不做不关本类自身事情
- 开放封闭原则：对扩展开放，对修改封闭
- 里氏替换原则：子类必须能够替换基类，否则不应当设计为其子类
- 依赖倒置原则：使用抽象接口，不直接依赖实现类，当实现类变换不需要更改使用接口
- 接口分离原则：模块之间要通过抽象接口隔离开，而不是通过具体的类耦合起来
- 最少知识原则：一个对象应当尽可能少的去了解其他对象，松耦合处理。

### 4.String属于基础类型么？Java八种基本类型？
不属于。  
Java 中 8 种基础的数据类型：byte、short、char、int、long、float、double、boolean  
但是 String 类型却是最常用到的引用类型。

### 5.String s="a"+"b"+"c"+"d";创建了几个对象？
1个  
编译器会优化，相当于直接定义一个 "abcd" 的字符串。

### 6.Math.round(-1.5) 等于多少？
运行结果： -1  
JDK 中的 java.lang.Math 类  
- ceil() ：向上取整，返回小数所在两整数间的较大值，返回类型是 double，如 -1.5 返回 -1.0
- floor() ：向下取整，返回小数所在两整数间的较小值，返回类型是 double，如 -1.5 返回 -2.0
- round() ：朝正无穷大方向返回参数最接近的整数，可以换算为 参数 + 0.5 向下取整，返回值是 int 或 long，如 -1.5 返回 -1

### 7.== 和 equals 的区别是什么?
- == 是关系运算符，equals() 是方法，结果都返回布尔值
- Object 的 == 和 equals() 比较的都是地址，作用相同

### 8.hashCode()相同，equals()也一定为true吗？
不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。
- 类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。
- hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。

关于 hashCode() 和 equals() 是方法是有一些 常规协定：  
- 两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。  
- 两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。  
- 重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。

### 9.重写和重载
- 重写：在子类中将父类的成员方法的名称保留，重新编写成员方法的实现内容，更改方法的访问权限，修改返回类型的为父类返回类型的子类。声明为 final、static 或 private 的方法不能被重写。
- 重载：一个类中允许同时存在一个以上的同名方法，这些方法的参数个数或者类型不同。无法以返回值类型作为重载函数的区分标准。

### 10.普通类和抽象类有哪些区别
- 抽象类不能被实例化
- 抽象类可以有抽象方法，抽象方法只需申明，无需实现
- 含有抽象方法的类必须申明为抽象类
- 抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类
- 抽象方法不能被声明为静态
- 抽象方法不能用 private 修饰
- 抽象方法不能用 final 修饰

### 11.抽象类必须要有抽象方法吗
不一定。如
```java
public abstract class TestAbstractClass {
 
	public static void notAbstractMethod() {
		System.out.println("I am not a abstract method.");
	}
	
}
```

### 12.深拷贝和浅拷贝区别是什么
复制一个 Java 对象
- 浅拷贝：复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针，不复制堆内存中的对象。（复制的是全新的对象，属性都复制了，除了子类对象还是跟被复制的子类对象是同一个）
- 深拷贝：复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针和堆内存中的对象。

浅拷贝实现：
- 实现 Cloneable 接口，重写 clone() 方法
- 不实现 Cloneable 接口，会报 CloneNotSupportedException 异常
- Object 的 clone() 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。

## 二、异常处理

### 1.异常和错误
- Error：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题
- Exception
    - RuntimeException：运行时异常，编译通过了，但运行时出现的异常
    - 非 RuntimeException：编译时（受检）异常，编译器检测到某段代码可能会发生某些问题，需要程序员提前给代码做出错误的解决方案，否则编译不通过

### 2.Java中如何进行异常处理
- 把各种不同的异常进行分类；
- 每个异常都是一个对象，是 Throwable 或其子类的实例；
- 一个方法出现异常后便抛出一个异常对象，该对象中包含有对象信息，调用对象的方法可以捕获这个异常并进行处理；
- Java 中的异常处理通过5个关键词实现：throw、throws、try、catch 和 finally

### 3.throws、throw、try、catch、finally分别如何使用
- throws：定义方法时，可以使用 throws 关键字抛出异常；
- throw：方法体内使用 throw 抛出异常；
- try：使用 try 执行一段代码，当出现异常后，停止后续代码的执行，跳至 catch 语句块；
- catch：使用 catch 来捕获指定的异常，并进行处理；
- finally：finally 语句块表示的语义是在 try、catch 语句块执行结束后，最后一定会被执行。

### 4.return与finally的执行顺序对返回值的影响
对于 try 和 finally 至少一个语句块包含 return 语句的情况：
- finally 语句块会执行
- finally 没有 return，finally 对 return 变量的重新赋值修改无效
- try 和 finally 都包含return，return 值会以 finally 语句块 return 值为准

## 三、反射
### 1.作用
- Java可以通过反射获取方法名称、方法参数和返回值类型等等，但无法获取参数名称
- 使用反射对类进行动态装配，降低代码耦合度。动态代理会使用到，但过分使用或严重消耗系统资源

JDK 中 java.lang.Class 类，就是为了实现反射提供的核心类之一。  
一个 jvm 中一种 Class 只会被加载一次。


## 四、文件IO
### 1.Java中有几种类型的流
- 字节流：继承自inputStream和OutputStream
- 字符流：继承自InputSteamReader和OutputStreamWriter

### 2.字符流和字节流有什么区别
字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过缓冲区（内存）然后通过缓冲区再操作文件。  
缓冲区：  
a.缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性。  
b.对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作。  
选择：  
a.大多数情况下使用字节流会更好，因为大多数时候 IO 操作都是直接操作磁盘文件，所以这些流在传输时都是以字节的方式进行的  
b.如果对于操作需要通过 IO 在内存中频繁处理字符串的情况使用字符流会好些，因为字符流具备缓冲区，提高了性能

### 3.什么是Java序列化，如何实现Java序列化？
序列化就是一种用来处理对象流的机制，将对象的内容进行流化。可以对流化后的对象进行读写操作，可以将流化后的对象传输于网络之间。序列化是为了解决在对象流读写操作时所引发的问题  
序列化的实现：将需要被序列化的类实现Serialize接口，没有需要实现的方法，此接口只是为了标注对象可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputStream(对象流)对象，再使用ObjectOutputStream对象的write(Object obj)方法就可以将参数obj的对象写出

### 4.BIO、NIO、AIO的区别
- BIO：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成
	- 先将文件内容从磁盘中拷贝到操作系统buffer
	- 再从操作系统buffer 拷贝到  程序应用（应用层）buffer
	- 从程序buffer拷贝到socket buffer
	- 从socket buffer拷贝到协议引擎.
- NIO：同步非阻塞的I/O模型
- AIO：异步非阻塞的IO模型



## 五、Java8 特性
### 1.Lambda
单抽象方法接口

### 2.JDK8中Stream接口的常用方法
中间操作：
- filter：过滤元素
- map：映射，将元素转换成其他形式或提取信息
- flatMap：扁平化流映射
- limit：截断流，使其元素不超过给定数量
- skip：跳过指定数量的元素
- sorted：排序
- distinct：去重

终端操作：
- anyMatch：检查流中是否有一个元素能匹配给定的谓词
- allMatch：检查谓词是否匹配所有元素
- noneMatch：检查是否没有任何元素与给定的谓词匹配
- findAny：返回当前流中的任意元素（用于并行的场景）
- findFirst：查找第一个元素
- collect：把流转换成其他形式，如集合 List、Map、Integer
- forEach：消费流中的每个元素并对其应用 Lambda，返回 void
- reduce：归约，如：求和、最大值、最小值
- count：返回流中元素的个数







