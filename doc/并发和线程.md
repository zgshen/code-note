
#### 1、qps和tps区别
QPS：Queries Per Second，意思是“每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器（比如是读写分离的架构，就是读的服务器）在规定时间内所处理流量多少的衡量标准。  

TPS：TransactionsPerSecond，意思是每秒事务数，一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。  

tps，即每秒处理事务数，每个事务包括了如下3个过程：
　　a.用户请求服务器  
　　b.服务器自己的内部处理（包含应用服务器、数据库服务器等）  
　　c.服务器返回给用户  
　　如果每秒能够完成N个这三个过程，tps就是N；

qps，如果是对一个页面请求一次，形成一个tps，但一次页面请求，可能产生多次对服务器的请求（页面上有很多html资源，比如图片等），服务器对这些请求，就可计入“Qps”之中；

 但是，如今的项目基本上都是前后端分离的，性能也分为前端性能和后端性能，通常默认是后端性能，即服务端性能，也就是对服务端接口做压测

如果是对一个接口（单场景）压测，且这个接口内部不会再去请求其它接口，那么tps=qps，否则，tps≠qps

如果是对多个接口（混合场景）压测，不加事务控制器，jmeter会统计每个接口的tps，而混合场景是要测试这个场景的tps，显然这样得不到混合场景的tps，所以，要加了事物控制器，结果才是整个场景的tps。

QPS（TPS）= 并发数/平均响应时间 或者 并发数 = QPS*平均响应时间
- 系统压力小的时候，并发数和QPS呈正相关，比如此时响应时间都小于1秒
- 当系统压力大的时候，比如响应时间远大于1秒，QPS可能会趋向最大值或反而会下降


#### 2、多线程什么情况下使用
- 多数据并行处理
- 异步请求网络  （例如发短信发邮件通知等等，不影响主业务逻辑）
- IO密集型业务  （文件读写，数据库操作）

#### 3、异步处理框架
Executor和Futrure，Rxjava安卓常用。线程池相关


#### 4、并行与并发
- 并行指多个事件在同一个时刻发生；并发指在某时刻只有一个事件在发生，某个时间段内由于 CPU 交替执行，可以发生多个事件。
- 并行没有对 CPU 资源的抢占；并发执行的线程需要对 CPU 资源进行抢占。
- 并行执行的线程之间不存在切换；并发操作系统会根据任务调度系统给线程分配线程的 CPU 执行时间，线程的执行会进行切换。

#### 5、Java线程池参数
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```
- corePoolSize 线程池核心线程大小  
    线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize
- maximumPoolSize 线程池最大线程数量  
    一个任务被提交到线程池后，首先会缓存到工作队列中，如果工作队列满了，则会创建一个新线程，然后从工作队列中的取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize来指定
- keepAliveTime 空闲线程存活时间  
    一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定
- unit 空间线程存活时间单位，即keepAliveTime的计量单位
- workQueue 工作队列  
    新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：
    - ArrayBlockingQueue 基于数组的有界阻塞队列，按FIFO排序。线程数最大执行拒绝策略。
    - LinkedBlockingQuene 基于链表的无界阻塞队列（实际最大Integer.MAX_VALUE），按FIFO排序。
    - SynchronousQuene 一个不缓存任务的阻塞队列。新任务进来时，不会缓存，而是直接被调度执行该任务。线程数最大执行拒绝策略。
    - PriorityBlockingQueue 具有优先级的无界阻塞队列，优先级通过参数Comparator实现。
- threadFactory 线程工厂
    创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等
- handler 拒绝策略  
    当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，拒绝处理方式：
    - CallerRunsPolicy 在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。  
    - AbortPolicy 直接丢弃任务，并抛出RejectedExecutionException异常。（默认方式）
    - DiscardPolicy 直接丢弃任务，什么都不做。
    - DiscardOldestPolicy 抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列
- allowCoreThreadTimeout 是否允许核心线程超时

#### 6、Java常用线程池
- newCachedThreadPool  
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    这种类型的线程池特点是：
    - 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
    - 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
    - 在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。

- newFixedThreadPool  
创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。  
FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。

- newSingleThreadExecutor  
创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。

- newScheduleThreadPool  
创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。


#### 7、悲观锁（select for update）和乐观锁
悲观锁：假设每一次拿数据，都有认为会被修改，所以给数据库的行或表上锁。要注意for update要用在索引上，不然会锁表。
```sql
START TRANSACTION; # 开启事务
select * from table_name where id=1 for update;
UPDATE table_name SET name= 'nike' WHERE id = 1;
COMMIT; # 提交事务
```

乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改。更新时如果version变化了，更新不会成功。
```sql
update status set name='nike',version=(version+1) where id=1 and version=version;
```

#### 8、对高并发的理解
实在的开发中 还真的没有遇到高并发的场景发生，以下都是纸上谈兵
- web端控制控制输入流，每次点击结束有个等待的过程，避免客户端重复点击，造成没有必要的浪费
- 服务端加服务器，nginx做负载均衡处理，进行分流处理 多台服务器去处理要求
- 存储和获取数据使用redis等缓存，经常被查询的数据使用通过 redis 避免多次查询数据库
- 数据库实行读写分离处理，减轻数据库的负担

#### 9、synchronized和Lock有什么区别？
- 实现层面不一样。synchronized 是 Java 关键字，JVM层面 实现加锁和释放锁；Lock 是一个接口，在代码层面实现加锁和释放锁
- 是否自动释放锁。synchronized 在线程代码执行完或出现异常时自动释放锁；Lock 不会自动释放锁，需要再 finally {} 代码块显式地中释放锁
- 是否一直等待。synchronized 会导致线程拿不到锁一直等待；Lock 可以设置尝试获取锁或者获取锁失败一定时间超时
- 获取锁成功是否可知。synchronized 无法得知是否获取锁成功；Lock 可以通过 tryLock 获得加锁是否成功
- 功能复杂性。synchronized 加锁可重入、不可中断、非公平；Lock 可重入、可判断、可公平和不公平、细分读写锁提高效率

#### sleep、wait、yield和join
sleep和wait
- sleep() 是 Thread 类的静态本地方法；wait() 是Object类的成员本地方法
- sleep() 方法可以在任何地方使用；wait() 方法则只能在同步方法或同步代码块中使用，否则抛出异常Exception in thread "Thread-0" java.lang.IllegalMonitorStateException
- sleep() 会休眠当前线程指定时间，释放 CPU 资源，不释放对象锁，休眠时间到自动苏醒继续执行；wait() 方法放弃持有的对象锁，进入等待队列，当该对象被调用 notify() / notifyAll() 方法后才有机会竞争获取对象锁，进入运行状态
- JDK1.8 sleep() wait() 均需要捕获 InterruptedException 异常
- wait(时间)，时间一到，不需要唤醒，可以自己重新抢锁，继续执行

yield
- 暂停当前正在执行的线程对象，不会释放资源锁！
- 和 sleep 不同的是 yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。还有一点和 sleep 不同的是 yield 方法只能使同优先级或更高优先级的线程有执行的机会

join
等待该线程终止。
等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。


