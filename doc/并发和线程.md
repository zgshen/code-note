
#### qps和tps区别
QPS：Queries Per Second，意思是“每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器（比如是读写分离的架构，就是读的服务器）在规定时间内所处理流量多少的衡量标准。  

TPS：TransactionsPerSecond，意思是每秒事务数，一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。  

tps，即每秒处理事务数，每个事务包括了如下3个过程：
　　a.用户请求服务器  
　　b.服务器自己的内部处理（包含应用服务器、数据库服务器等）  
　　c.服务器返回给用户  
　　如果每秒能够完成N个这三个过程，tps就是N；

qps，如果是对一个页面请求一次，形成一个tps，但一次页面请求，可能产生多次对服务器的请求（页面上有很多html资源，比如图片等），服务器对这些请求，就可计入“Qps”之中；

 但是，如今的项目基本上都是前后端分离的，性能也分为前端性能和后端性能，通常默认是后端性能，即服务端性能，也就是对服务端接口做压测

如果是对一个接口（单场景）压测，且这个接口内部不会再去请求其它接口，那么tps=qps，否则，tps≠qps

如果是对多个接口（混合场景）压测，不加事务控制器，jmeter会统计每个接口的tps，而混合场景是要测试这个场景的tps，显然这样得不到混合场景的tps，所以，要加了事物控制器，结果才是整个场景的tps。

QPS（TPS）= 并发数/平均响应时间 或者 并发数 = QPS*平均响应时间
- 系统压力小的时候，并发数和QPS呈正相关，比如此时响应时间都小于1秒
- 当系统压力大的时候，比如响应时间远大于1秒，QPS可能会趋向最大值或反而会下降


#### 多线程什么情况下使用
- 多数据并行处理
- 异步请求网络  （发短信发邮件通知，无法主业务）
- IO密集型业务  （文件读写，数据库操作）

#### 异步处理框架
Executor和Futrure，Rxjava安卓常用。线程池相关


#### 并行与并发
- 并行指多个事件在同一个时刻发生；并发指在某时刻只有一个事件在发生，某个时间段内由于 CPU 交替执行，可以发生多个事件。
- 并行没有对 CPU 资源的抢占；并发执行的线程需要对 CPU 资源进行抢占。
- 并行执行的线程之间不存在切换；并发操作系统会根据任务调度系统给线程分配线程的 CPU 执行时间，线程的执行会进行切换。

#### Java常用线程池
- newCachedThreadPool  
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    这种类型的线程池特点是：
    - 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
    - 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
    - 在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。

- newFixedThreadPool  
创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。  
FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。

- newSingleThreadExecutor  
创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。

- newScheduleThreadPool  
创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。


#### 悲观锁（select for update）和乐观锁
悲观锁：假设每一次拿数据，都有认为会被修改，所以给数据库的行或表上锁。要注意for update要用在索引上，不然会锁表。
```sql
START TRANSACTION; # 开启事务
select * from table_name where id=1 for update;
UPDATE table_name SET name= 'nike' WHERE id = 1;
COMMIT; # 提交事务
```

乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改。更新时如果version变化了，更新不会成功。
```sql
update status set name='nike',version=(version+1) where id=1 and version=version;
```

#### 对高并发的理解
实在的开发中 还真的没有遇到高并发的场景发生，以下都是纸上谈兵
- web端控制控制输入流，每次点击结束有个等待的过程，避免客户端重复点击，造成没有必要的浪费
- 服务端加服务器，nginx做负载均衡处理，进行分流处理 多台服务器去处理要求
- 存储和获取数据使用redis等缓存 经常被查询的数据落入到redis避免多次链接数据库
- 数据库实行读写分离处理，减轻数据库的负担

