## 1. Java内存模型
### 1.1. 主内存和工作内存
规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。  
不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。

### 1.2. volatile禁止指令重排序，保证变量对所有线程的可见性
单例模式用到，new对象不是原子操作，分三步
- 分配内存空间
- 初始化对象
- 对象引用指向分配的地址  

由于cpu可能的优化排序，第三步可能会先与第二步执行，这时其他线程读到就会由问题，可用volatile禁止指令重排序避免此问题

### 1.3. 并发编程三个特性
- 原子性：一个操作中cpu不能中断，要么不执行，要么执行完成
- 可见性：多线程访问变量，一个线程修改了变量，其他线程能够立即看到修改值
- 有序性：按照代码顺序执行

## 2. JVM
### 2.1. JVM 内存模型
- 类加载器子系统
- 运行时数据区
- 执行引擎

### 2.2. 内存空间，运行时数据区
#### 2.2.1. 虚拟机栈
栈是线程私有，用来存放局部变量、对象引用和常量池引用。方法执行的时候会创建一个栈帧，存储了**局部变量表、操作数栈、动态链接和方法出口信息**。每个方法从调用到执行完毕，对应一个栈帧在虚拟机中的入栈和出栈。  
Java 虚拟机栈会出现两种错误：  
*StackOverFlowError* ：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。  
*OutOfMemoryError* ： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。

#### 2.2.2. 本地方法栈
线程私有，和虚拟机栈类似，主要为虚拟机使用到的 Native 方法服务，也会抛出 `StackOverFlowError ` 和 `OutOfMemoryError`。

#### 2.2.3. 程序计数器
线程私有，是当前线程锁执行字节码的行号治时期，每条线程都有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果是 Native 方法，则为空。

#### 2.2.4. 堆
线程共享，在虚拟机启动的时候创建，用于存放对象实例。通过-Xmx 和-Xms 来控制大小。  
分为新生代、老年代。（方法区中的永久代在 JDK 1.8及之后已经移除）。  
新生代可分为 Eden 空间、From Survivor 和 To Survivor 空间等。  
堆容易出现的错误是 OutOfMemoryError 错误，表现有几种：
- OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
- java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！)

#### 2.2.5. 方法区
线程共享，存储要加载类信息、静态变量、final 类型的常量、属性和方法信息。  
永久代是方法区的一种实现，JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小：
```
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常 `java.lang.OutOfMemoryError: PermGen`
```
JDK 1.8及之后永久代被彻底移除了，取代的是元空间，元空间使用的是直接内存，常用设置参数：
```
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
永久代 (PermGen) 替换为元空间 (MetaSpace)原因是永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，只受本机可用内存的限制。元空间也会溢出，但比原来出现的几率小。  
运行时常量池也在方法区中。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量和符号引用。常量池中存放的是对象引用，而不是真实的对象。  
JDK1.7 之前的运行时常量池，包含字符串常量池存放在方法区，JDK1.7 开始把字符串常量池和静态变量从方法区拿到了堆中。到 JDK1.8 使用元空间替代永久区来实现方法区，此时运行时常量池在元空间，字符串常量池在堆，但逻辑上讲这两个都在方法区。

### 2.3. 类加载过程
- 加载：
	- 获取类的二进制字节流
	- 将字节流代表的静态存储结构转化为方法区运行时数据结构
	- 在堆中生成class字节码对象
- 验证：连接过程的第一步，确保 class 文件的字节流中的信息符合当前 JVM 的要求，不会危害 JVM 的安全
- 准备：为类的静态变量分配内存并将其初始化为默认值
- 解析：JVM 将常量池内符号引用替换成直接引用的过程
- 初始化：执行类构造器的初始化的过程

### 2.4. 类加载机制
#### 2.4.1. 类加载器
-  启动类加载器 BootstrapClassLoad  rt.jar
-  扩展类加载器 ExtClassLoad  ext目录下扩展jar
-  应用程序类加载器 AppClassLoad  claddpath上的类

#### 2.4.2. 双亲委派机制
一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

#### 2.4.3. 双亲委派机制如何打破
- 自定义类加载器实现，重写自定义加载器的loadClass(),jdk不推荐。一般都只是重写findClass()，这样可以保持双亲委派机制.而loadClass方法加载规则由自己定义，就可以随心所欲的加载类了
- JDBC驱动例子，DriverManager在rt.jar，加载器是BootstrapClassLoader，JDBC驱动是三方开发，要由一般都指向AppClassLoader加载。Thread.currentThread().getContextClassLoader()和ClassLoader.getSystemClassLoader()一般都指向AppClassLoader，SPI用Thread.currentThread().getContextClassLoader()来加载实现类，实现在核心包里的基础类调用用户代码（使用线程上下文类加载器也就是应用程序类加载器来加载这些类）

### 2.5. 类初始化顺序
- 静态变量/静态代码块，普通代码块，构造器
- 父类静态变量/静态代码块→子类静态变量/静态代码块→父类普通代码块→父类构造器→子类普通代码块→子类构造器
- 子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了；（父类静态-子类静态-父类普通初始化块-子类普通初始化块。跟上面其实重复）
- 静态变量、静态初始化块顺序取决于它们在类中出现的先后顺序
- 变量、初始化块初始化顺序取决于它们在类中出现的先后顺序

### 2.6. 垃圾回收判断
- 引用计数算法：引用数为0的对象回收，难以解决对象循环引用问题
- 根搜索法（可达性算法）：从 GC Root 对象开始向下搜索，可达的对象都是存活的，不可达的对象无法被回收

### 2.7. 垃圾回收算法
判断对象已死去的方法有引用计数法（已淘汰）和根搜索法（可达性分析算法）
- 标记-清除算法：先标记需要清除对象，遍历清除，容易产生内存碎片
- 复制算法：分两块内存，把存活对象复制到另一块内存上，再把第一块内存所有对象清除
- 标记-整理算法：将标记的存活对象都像一端移动，清理端边界以外的内存（老年代）
- 增量算法
- 分代收集算法：不同的代采用不同是算法。
	- 年轻代采用复制算法，因为大部分对象都是朝生夕死；
	- Eden区和From Survivor回收后存活对象复制到To Survivor
	- 默认15次没被回收的对象会被复制到Old区
	- Old区也被填满时，进行Full GC，对Old区进行垃圾回收

### 2.8. 垃圾回收器
- Serial 收集器
- ParNew 收集器
- Parallel Scavenge 收集器
- Serial Old 收集器
- Parallel Old 收集器
- CMS 收集器
- G1 收集器

### 2.9. 内存分配与回收策略
#### 2.9.1. Minor GC 和 Full GC
- Minor GC：回收新生代，因为新生代对象存活时间很短，因此会频繁执行，速度较快
- Full GC：回收老年代和新生代，老年代对象存活时间长，因此 Full GC 很少执行，
执行速度会比 Minor GC 慢很多

#### 2.9.2. 内存分配策略
- 对象有限在 Eden 分配
- 大对象直接进入老年代
- 长期存活的对象进入老年代
- 动态对象年龄判定
- 空间分配担保

#### 2.9.3. Full GC 触发条件
- 调用 System.gc()
- 空间分配担保失败
- JDK1.7 以前的永久代空间不足

### 2.10. GC过程
Eden Survival

### 2.11. 内存泄漏和内存溢出的区别
- 内存溢出(out of memory)：指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory。
- 内存泄露(memory leak)：指程序在申请内存后，无法释放已申请的内存空间，内存泄露堆积会导致内存被占光。(静态集合类、各类数据库和网络连接用完不关闭、内部类持有外部类、改变哈希值)
- memory leak 最终会导致 out of memory。

### 2.12. OOM相关
##### 2.12.1. 堆溢出
- 1)内存泄漏（Memory Leak）：使用工具查看泄漏对象到GC ROOTS的引用链，找到泄漏对象是通过怎么样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们，准确地定位出泄漏代码的位置。
- 2)内存溢出(Memory overflow)：如果不是内存泄漏，换句话说，就是内存中的对象确实都还必须活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。
##### 2.12.2. 栈内存溢出（-Xss）
- 1)如果线程请求的深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果栈的深度小或者栈针的容量比较大、用递归时，都可能引起。
- 2)如果是虚拟机在扩展时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。当使用多线程的时候，需要注意。
##### 2.12.3. 方法区和运行时常量池溢出（-XX:PermSize -XX:MaxPermSize）
- 1)常量池中存放大量的String对象，并保持对这些对象的引用，避免Full GC回收常量池，就会产生OutOfMemoryError异常，后面跟的提示信息是“PermGen space”,说明运行时常量池属于方法区。
- 2)方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当产生大量的类去填充满方法区，就会溢出
- 3)Jdk1.8之后方法区由元空间替代，字符串常量池和类静态变量都放到堆中了，因为不好指定大小和容易内存溢出，增加GC复杂度，回事效率低
##### 2.12.4. 本机直接内存溢出（-MaxDirectMemorySize）
DirectMemory容量可通过MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值一样。虽然DirectMemory内存溢出时也会抛出内存溢出异常，但它抛出的异常时并没有真正向操作系统申请内存分配，于是手动抛出异常。一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而且程序中又直接或者间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。

### 2.13. 常见OOM和解决方法
- Java堆空间
	- 原因：无法在 Java 堆中分配对象；应用程序无意中保存了对象引用，对象无法被 GC 回收；应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长
	- 解决：使用 -Xmx 增加堆大小；修复应用程序中的内存泄漏
- GC 开销超过限制
	- 原因：Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。
	- 解决：使用 -Xmx 增加堆大小;使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制;修复应用程序中的内存泄漏
- Requested array size exceeds VM limit 应用程序试图分配一个大于堆大小的数组
	- 原因：应用程序试图分配一个超过堆大小的数组
	- 解决：使用 -Xmx 增加堆大小;修复应用程序中分配巨大数组的 bug
- Perm gen 空间
	- 原因：当 Perm gen 空间用尽时，将抛出异常。Perm gen 空间包含：类的名字、字段、方法；与类相关的对象数组和类型数组；JIT 编译器优化
	- 解决：使用 -XX: MaxPermSize 增加 Permgen 大小；不重启应用部署应用程序可能会导致此问题。重启 JVM 解决
- Metaspace 元空间
	- 原因：从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常
	- 解决：通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小；取消 -XX: maxmetsspacedize；减小 Java 堆大小,为 MetaSpace 提供更多的可用空间；为服务器分配更多的内存；修复bug
- unable to create new native thread 无法新建本机线程
	- 原因：内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足
	- 解决：将 heap 及 perm 的最大值下调，并将线程栈内存 -Xss 调小；修复应用程序中的线程泄漏；增加操作系统级别的限制
`ulimit -a`；用户进程数增大 (-u) 1800；使用 -Xss 减小线程堆栈大小
- 杀死进程或子进程
	- 原因：内核任务在可用内存极低的情况下会杀死进程
	- 解决：将进程迁移到不同的机器上；给机器增加更多内存；与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的
- 发生 stack_trace_with_native_method
	- 原因：本机方法（native method）分配失败；打印的堆栈跟踪信息，最顶层的帧是本机方法
	- 解决：使用操作系统本地工具进行诊断

### 2.14. JVM 调优
JVM调优是比较高深的学问，包括设置合理的内存参数，选择合理垃圾回收器甚至修改 JVM 代码等等。在一般项目中很少会去做具体调优。比较常用简单的优化：
- 堆设置合理的-Xmx 和-Xms大小，一般两个值设为一样，避免每次 GC 后调整堆的大小；
- 设置新生代和老年代比例；
- 开启 GC 日志，查看 GC 情况，排查解决 Full GC 频繁原因；
- 使用  Jconsole 监控工具监控线程和堆空间分配。
