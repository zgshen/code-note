## 一、Java内存模型
### 1.主内存和工作内存
规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成

### 2.volatile禁止指令重排序，保证变量对所有线程的可见性
单例模式用到，new对象不是原子操作，分三步
- 分配内存空间
- 初始化对象
- 对象引用指向分配的地址  

由于cpu可能的优化排序，第三步可能会先与第二步执行，这时其他线程读到就会由问题，可用volatile禁止指令重排序避免此问题

### 3.并发编程三个特性
- 原子性：一个操作中cpu不能中断，要么不执行，要么执行完成
- 可见性：多线程访问变量，一个线程修改了变量，其他线程能够立即看到修改值
- 有序性：按照代码顺序执行

## 二、JVM
### 1.JVM 内存模型
- 类加载器子系统
- 运行时数据区
- 执行引擎

### 2.内存空间，运行时数据区
- 虚拟机栈，Java栈（线程私有）：每个方法都会在栈内存中创建栈帧，用于局部变量表、操作数栈、常量池引用等信息
- 本地方法栈（线程私有）：类似虚拟机栈，为本地方法创建
- 程序计数器（线程私有）：线程私有，记录线程执行到哪里了
- 堆（线程共享）：存储对象实例
- 方法区（线程共享。1.8实现为元空间[用的本地内存]，之前是永久代[跟堆连续在一起但又是隔离开的]）：类信息、常量、静态变量和编译后代码等数据（1.8字符串常量池和类静态变量都放到堆中了，因为不好指定大小和容易内存溢出，增加GC复杂度，回事效率低）

### 3.类加载过程
- 加载：
	- 获取类的二进制字节流
	- 将字节流代表的静态存储结构转化为方法区运行时数据结构
	- 在堆中生成class字节码对象
- 验证：连接过程的第一步，确保 class 文件的字节流中的信息符合当前 JVM 的要求，不会危害 JVM 的安全
- 准备：为类的静态变量分配内存并将其初始化为默认值
- 解析：JVM 将常量池内符号引用替换成直接引用的过程
- 初始化：执行类构造器的初始化的过程

### 4.类加载机制
#### 类加载器
-  启动类加载器 BootstrapClassLoad  rt.jar
-  扩展类加载器 ExtClassLoad  ext目录下扩展jar
-  应用程序类加载器 AppClassLoad  claddpath上的类

#### 双亲委派机制
一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

#### 双亲委派机制如何打破
- 自定义类加载器实现，重写自定义加载器的loadClass(),jdk不推荐。一般都只是重写findClass()，这样可以保持双亲委派机制.而loadClass方法加载规则由自己定义，就可以随心所欲的加载类了
- JDBC驱动例子，DriverManager在rt.jar，加载器是BootstrapClassLoader，JDBC驱动是三方开发，要由一般都指向AppClassLoader加载。Thread.currentThread().getContextClassLoader()和ClassLoader.getSystemClassLoader()一般都指向AppClassLoader，SPI用Thread.currentThread().getContextClassLoader()来加载实现类，实现在核心包里的基础类调用用户代码（使用线程上下文类加载器也就是应用程序类加载器来加载这些类）

### 5.类初始化顺序
- 静态变量/静态代码块，普通代码块，构造器
- 父类静态变量/静态代码块→子类静态变量/静态代码块→父类普通代码块→父类构造器→子类普通代码块→子类构造器
- 子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了；（父类静态-子类静态-父类普通初始化块-子类普通初始化块。跟上面其实重复）
- 静态变量、静态初始化块顺序取决于它们在类中出现的先后顺序
- 变量、初始化块初始化顺序取决于它们在类中出现的先后顺序

### 6.垃圾回收判断
- 引用计数算法：引用数为0的对象回收，难以解决对象循环引用问题
- 根搜索法（可达性算法）：从 GC Root 对象开始向下搜索，可达的对象都是存活的，不可达的对象无法被回收

### 7.垃圾回收算法
判断对象已死去的方法有引用计数法（已淘汰）和根搜索法（可达性分析算法）
- 标记-清除算法：先标记需要清除对象，遍历清除，容易产生内存碎片
- 复制算法：分两块内存，把存活对象复制到另一块内存上，再把第一块内存所有对象清除
- 标记-整理算法：将标记的存活对象都像一端移动，清理端边界以外的内存（老年代）
- 增量算法
- 分代收集算法：不同的代采用不同是算法。
	- 年轻代采用复制算法，因为大部分对象都是朝生夕死；
	- Eden区和From Survivor回收后存活对象复制到To Survivor
	- 默认15次没被回收的对象会被复制到Old区
	- Old区也被填满时，进行Full GC，对Old区进行垃圾回收

### 8.垃圾回收器
- Serial 收集器
- ParNew 收集器
- Parallel Scavenge 收集器
- Serial Old 收集器
- Parallel Old 收集器
- CMS 收集器
- G1 收集器

### 9.内存分配与回收策略
#### Minor GC 和 Full GC
- Minor GC：回收新生代，因为新生代对象存活时间很短，因此会频繁执行，速度较快
- Full GC：回收老年代和新生代，老年代对象存活时间长，因此 Full GC 很少执行，
执行速度会比 Minor GC 慢很多

#### 内存分配策略
- 对象有限在 Eden 分配
- 大对象直接进入老年代
- 长期存活的对象进入老年代
- 动态对象年龄判定
- 空间分配担保

#### Full GC 触发条件
- 调用 System.gc()
- 空间分配担保失败
- JDK1.7 以前的永久代空间不足

### 10.内存泄漏和内存溢出的区别
- 内存溢出(out of memory)：指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory。
- 内存泄露(memory leak)：指程序在申请内存后，无法释放已申请的内存空间，内存泄露堆积会导致内存被占光。(静态集合类、各类数据库和网络连接用完不关闭、内部类持有外部类、改变哈希值)
- memory leak 最终会导致 out of memory。

### 11.OOM相关
##### 堆溢出
- 1)内存泄漏（Memory Leak）：使用工具查看泄漏对象到GC ROOTS的引用链，找到泄漏对象是通过怎么样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们，准确地定位出泄漏代码的位置。
- 2)内存溢出(Memory overflow)：如果不是内存泄漏，换句话说，就是内存中的对象确实都还必须活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。
##### 栈内存溢出（-Xss）
- 1)如果线程请求的深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果栈的深度小或者栈针的容量比较大、用递归时，都可能引起。
- 2)如果是虚拟机在扩展时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。当使用多线程的时候，需要注意。
##### 方法区和运行时常量池溢出（-XX:PermSize -XX:MaxPermSize）
- 1)常量池中存放大量的String对象，并保持对这些对象的引用，避免Full GC回收常量池，就会产生OutOfMemoryError异常，后面跟的提示信息是“PermGen space”,说明运行时常量池属于方法区。
- 2)方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当产生大量的类去填充满方法区，就会溢出
- 3)Jdk1.8之后方法区由元空间替代，字符串常量池和类静态变量都放到堆中了，因为不好指定大小和容易内存溢出，增加GC复杂度，回事效率低
##### 本机直接内存溢出（-MaxDirectMemorySize）
DirectMemory容量可通过MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值一样。虽然DirectMemory内存溢出时也会抛出内存溢出异常，但它抛出的异常时并没有真正向操作系统申请内存分配，于是手动抛出异常。一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而且程序中又直接或者间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。

7、常见OOM和解决方法
- Java堆空间
	- 原因：无法在 Java 堆中分配对象；应用程序无意中保存了对象引用，对象无法被 GC 回收；应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长
	- 解决：使用 -Xmx 增加堆大小；修复应用程序中的内存泄漏
- GC 开销超过限制
	- 原因：Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。
	- 解决：使用 -Xmx 增加堆大小;使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制;修复应用程序中的内存泄漏
- Requested array size exceeds VM limit 应用程序试图分配一个大于堆大小的数组
	- 原因：应用程序试图分配一个超过堆大小的数组
	- 解决：使用 -Xmx 增加堆大小;修复应用程序中分配巨大数组的 bug
- Perm gen 空间
	- 原因：当 Perm gen 空间用尽时，将抛出异常。Perm gen 空间包含：类的名字、字段、方法；与类相关的对象数组和类型数组；JIT 编译器优化
	- 解决：使用 -XX: MaxPermSize 增加 Permgen 大小；不重启应用部署应用程序可能会导致此问题。重启 JVM 解决
- Metaspace 元空间
	- 原因：从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常
	- 解决：通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小；取消 -XX: maxmetsspacedize；减小 Java 堆大小,为 MetaSpace 提供更多的可用空间；为服务器分配更多的内存；修复bug
- unable to create new native thread 无法新建本机线程
	- 原因：内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足
	- 解决：将 heap 及 perm 的最大值下调，并将线程栈内存 -Xss 调小；修复应用程序中的线程泄漏；增加操作系统级别的限制
`ulimit -a`；用户进程数增大 (-u) 1800；使用 -Xss 减小线程堆栈大小
- 杀死进程或子进程
	- 原因：内核任务在可用内存极低的情况下会杀死进程
	- 解决：将进程迁移到不同的机器上；给机器增加更多内存；与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的
- 发生 stack_trace_with_native_method
	- 原因：本机方法（native method）分配失败；打印的堆栈跟踪信息，最顶层的帧是本机方法
	- 解决：使用操作系统本地工具进行诊断